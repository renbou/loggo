package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/renbou/loggo/pkg/api/telemetry.Telemetry_StreamLogMessagesServer -o ./telemetry__stream_log_messages_server_mock.go -n Telemetry_StreamLogMessagesServerMock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_telemetry "github.com/renbou/loggo/pkg/api/telemetry"
	"google.golang.org/grpc/metadata"
)

// Telemetry_StreamLogMessagesServerMock implements telemetry.Telemetry_StreamLogMessagesServer
type Telemetry_StreamLogMessagesServerMock struct {
	t minimock.Tester

	funcContext          func() (c1 context.Context)
	inspectFuncContext   func()
	afterContextCounter  uint64
	beforeContextCounter uint64
	ContextMock          mTelemetry_StreamLogMessagesServerMockContext

	funcRecvMsg          func(m interface{}) (err error)
	inspectFuncRecvMsg   func(m interface{})
	afterRecvMsgCounter  uint64
	beforeRecvMsgCounter uint64
	RecvMsgMock          mTelemetry_StreamLogMessagesServerMockRecvMsg

	funcSend          func(sp1 *mm_telemetry.StreamLogMessagesResponse) (err error)
	inspectFuncSend   func(sp1 *mm_telemetry.StreamLogMessagesResponse)
	afterSendCounter  uint64
	beforeSendCounter uint64
	SendMock          mTelemetry_StreamLogMessagesServerMockSend

	funcSendHeader          func(m1 metadata.MD) (err error)
	inspectFuncSendHeader   func(m1 metadata.MD)
	afterSendHeaderCounter  uint64
	beforeSendHeaderCounter uint64
	SendHeaderMock          mTelemetry_StreamLogMessagesServerMockSendHeader

	funcSendMsg          func(m interface{}) (err error)
	inspectFuncSendMsg   func(m interface{})
	afterSendMsgCounter  uint64
	beforeSendMsgCounter uint64
	SendMsgMock          mTelemetry_StreamLogMessagesServerMockSendMsg

	funcSetHeader          func(m1 metadata.MD) (err error)
	inspectFuncSetHeader   func(m1 metadata.MD)
	afterSetHeaderCounter  uint64
	beforeSetHeaderCounter uint64
	SetHeaderMock          mTelemetry_StreamLogMessagesServerMockSetHeader

	funcSetTrailer          func(m1 metadata.MD)
	inspectFuncSetTrailer   func(m1 metadata.MD)
	afterSetTrailerCounter  uint64
	beforeSetTrailerCounter uint64
	SetTrailerMock          mTelemetry_StreamLogMessagesServerMockSetTrailer
}

// NewTelemetry_StreamLogMessagesServerMock returns a mock for telemetry.Telemetry_StreamLogMessagesServer
func NewTelemetry_StreamLogMessagesServerMock(t minimock.Tester) *Telemetry_StreamLogMessagesServerMock {
	m := &Telemetry_StreamLogMessagesServerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ContextMock = mTelemetry_StreamLogMessagesServerMockContext{mock: m}

	m.RecvMsgMock = mTelemetry_StreamLogMessagesServerMockRecvMsg{mock: m}
	m.RecvMsgMock.callArgs = []*Telemetry_StreamLogMessagesServerMockRecvMsgParams{}

	m.SendMock = mTelemetry_StreamLogMessagesServerMockSend{mock: m}
	m.SendMock.callArgs = []*Telemetry_StreamLogMessagesServerMockSendParams{}

	m.SendHeaderMock = mTelemetry_StreamLogMessagesServerMockSendHeader{mock: m}
	m.SendHeaderMock.callArgs = []*Telemetry_StreamLogMessagesServerMockSendHeaderParams{}

	m.SendMsgMock = mTelemetry_StreamLogMessagesServerMockSendMsg{mock: m}
	m.SendMsgMock.callArgs = []*Telemetry_StreamLogMessagesServerMockSendMsgParams{}

	m.SetHeaderMock = mTelemetry_StreamLogMessagesServerMockSetHeader{mock: m}
	m.SetHeaderMock.callArgs = []*Telemetry_StreamLogMessagesServerMockSetHeaderParams{}

	m.SetTrailerMock = mTelemetry_StreamLogMessagesServerMockSetTrailer{mock: m}
	m.SetTrailerMock.callArgs = []*Telemetry_StreamLogMessagesServerMockSetTrailerParams{}

	return m
}

type mTelemetry_StreamLogMessagesServerMockContext struct {
	mock               *Telemetry_StreamLogMessagesServerMock
	defaultExpectation *Telemetry_StreamLogMessagesServerMockContextExpectation
	expectations       []*Telemetry_StreamLogMessagesServerMockContextExpectation
}

// Telemetry_StreamLogMessagesServerMockContextExpectation specifies expectation struct of the Telemetry_StreamLogMessagesServer.Context
type Telemetry_StreamLogMessagesServerMockContextExpectation struct {
	mock *Telemetry_StreamLogMessagesServerMock

	results *Telemetry_StreamLogMessagesServerMockContextResults
	Counter uint64
}

// Telemetry_StreamLogMessagesServerMockContextResults contains results of the Telemetry_StreamLogMessagesServer.Context
type Telemetry_StreamLogMessagesServerMockContextResults struct {
	c1 context.Context
}

// Expect sets up expected params for Telemetry_StreamLogMessagesServer.Context
func (mmContext *mTelemetry_StreamLogMessagesServerMockContext) Expect() *mTelemetry_StreamLogMessagesServerMockContext {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.Context mock is already set by Set")
	}

	if mmContext.defaultExpectation == nil {
		mmContext.defaultExpectation = &Telemetry_StreamLogMessagesServerMockContextExpectation{}
	}

	return mmContext
}

// Inspect accepts an inspector function that has same arguments as the Telemetry_StreamLogMessagesServer.Context
func (mmContext *mTelemetry_StreamLogMessagesServerMockContext) Inspect(f func()) *mTelemetry_StreamLogMessagesServerMockContext {
	if mmContext.mock.inspectFuncContext != nil {
		mmContext.mock.t.Fatalf("Inspect function is already set for Telemetry_StreamLogMessagesServerMock.Context")
	}

	mmContext.mock.inspectFuncContext = f

	return mmContext
}

// Return sets up results that will be returned by Telemetry_StreamLogMessagesServer.Context
func (mmContext *mTelemetry_StreamLogMessagesServerMockContext) Return(c1 context.Context) *Telemetry_StreamLogMessagesServerMock {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.Context mock is already set by Set")
	}

	if mmContext.defaultExpectation == nil {
		mmContext.defaultExpectation = &Telemetry_StreamLogMessagesServerMockContextExpectation{mock: mmContext.mock}
	}
	mmContext.defaultExpectation.results = &Telemetry_StreamLogMessagesServerMockContextResults{c1}
	return mmContext.mock
}

// Set uses given function f to mock the Telemetry_StreamLogMessagesServer.Context method
func (mmContext *mTelemetry_StreamLogMessagesServerMockContext) Set(f func() (c1 context.Context)) *Telemetry_StreamLogMessagesServerMock {
	if mmContext.defaultExpectation != nil {
		mmContext.mock.t.Fatalf("Default expectation is already set for the Telemetry_StreamLogMessagesServer.Context method")
	}

	if len(mmContext.expectations) > 0 {
		mmContext.mock.t.Fatalf("Some expectations are already set for the Telemetry_StreamLogMessagesServer.Context method")
	}

	mmContext.mock.funcContext = f
	return mmContext.mock
}

// Context implements telemetry.Telemetry_StreamLogMessagesServer
func (mmContext *Telemetry_StreamLogMessagesServerMock) Context() (c1 context.Context) {
	mm_atomic.AddUint64(&mmContext.beforeContextCounter, 1)
	defer mm_atomic.AddUint64(&mmContext.afterContextCounter, 1)

	if mmContext.inspectFuncContext != nil {
		mmContext.inspectFuncContext()
	}

	if mmContext.ContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContext.ContextMock.defaultExpectation.Counter, 1)

		mm_results := mmContext.ContextMock.defaultExpectation.results
		if mm_results == nil {
			mmContext.t.Fatal("No results are set for the Telemetry_StreamLogMessagesServerMock.Context")
		}
		return (*mm_results).c1
	}
	if mmContext.funcContext != nil {
		return mmContext.funcContext()
	}
	mmContext.t.Fatalf("Unexpected call to Telemetry_StreamLogMessagesServerMock.Context.")
	return
}

// ContextAfterCounter returns a count of finished Telemetry_StreamLogMessagesServerMock.Context invocations
func (mmContext *Telemetry_StreamLogMessagesServerMock) ContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContext.afterContextCounter)
}

// ContextBeforeCounter returns a count of Telemetry_StreamLogMessagesServerMock.Context invocations
func (mmContext *Telemetry_StreamLogMessagesServerMock) ContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContext.beforeContextCounter)
}

// MinimockContextDone returns true if the count of the Context invocations corresponds
// the number of defined expectations
func (m *Telemetry_StreamLogMessagesServerMock) MinimockContextDone() bool {
	for _, e := range m.ContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContext != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockContextInspect logs each unmet expectation
func (m *Telemetry_StreamLogMessagesServerMock) MinimockContextInspect() {
	for _, e := range m.ContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.Context")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.Context")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContext != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.Context")
	}
}

type mTelemetry_StreamLogMessagesServerMockRecvMsg struct {
	mock               *Telemetry_StreamLogMessagesServerMock
	defaultExpectation *Telemetry_StreamLogMessagesServerMockRecvMsgExpectation
	expectations       []*Telemetry_StreamLogMessagesServerMockRecvMsgExpectation

	callArgs []*Telemetry_StreamLogMessagesServerMockRecvMsgParams
	mutex    sync.RWMutex
}

// Telemetry_StreamLogMessagesServerMockRecvMsgExpectation specifies expectation struct of the Telemetry_StreamLogMessagesServer.RecvMsg
type Telemetry_StreamLogMessagesServerMockRecvMsgExpectation struct {
	mock    *Telemetry_StreamLogMessagesServerMock
	params  *Telemetry_StreamLogMessagesServerMockRecvMsgParams
	results *Telemetry_StreamLogMessagesServerMockRecvMsgResults
	Counter uint64
}

// Telemetry_StreamLogMessagesServerMockRecvMsgParams contains parameters of the Telemetry_StreamLogMessagesServer.RecvMsg
type Telemetry_StreamLogMessagesServerMockRecvMsgParams struct {
	m interface{}
}

// Telemetry_StreamLogMessagesServerMockRecvMsgResults contains results of the Telemetry_StreamLogMessagesServer.RecvMsg
type Telemetry_StreamLogMessagesServerMockRecvMsgResults struct {
	err error
}

// Expect sets up expected params for Telemetry_StreamLogMessagesServer.RecvMsg
func (mmRecvMsg *mTelemetry_StreamLogMessagesServerMockRecvMsg) Expect(m interface{}) *mTelemetry_StreamLogMessagesServerMockRecvMsg {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.RecvMsg mock is already set by Set")
	}

	if mmRecvMsg.defaultExpectation == nil {
		mmRecvMsg.defaultExpectation = &Telemetry_StreamLogMessagesServerMockRecvMsgExpectation{}
	}

	mmRecvMsg.defaultExpectation.params = &Telemetry_StreamLogMessagesServerMockRecvMsgParams{m}
	for _, e := range mmRecvMsg.expectations {
		if minimock.Equal(e.params, mmRecvMsg.defaultExpectation.params) {
			mmRecvMsg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRecvMsg.defaultExpectation.params)
		}
	}

	return mmRecvMsg
}

// Inspect accepts an inspector function that has same arguments as the Telemetry_StreamLogMessagesServer.RecvMsg
func (mmRecvMsg *mTelemetry_StreamLogMessagesServerMockRecvMsg) Inspect(f func(m interface{})) *mTelemetry_StreamLogMessagesServerMockRecvMsg {
	if mmRecvMsg.mock.inspectFuncRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("Inspect function is already set for Telemetry_StreamLogMessagesServerMock.RecvMsg")
	}

	mmRecvMsg.mock.inspectFuncRecvMsg = f

	return mmRecvMsg
}

// Return sets up results that will be returned by Telemetry_StreamLogMessagesServer.RecvMsg
func (mmRecvMsg *mTelemetry_StreamLogMessagesServerMockRecvMsg) Return(err error) *Telemetry_StreamLogMessagesServerMock {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.RecvMsg mock is already set by Set")
	}

	if mmRecvMsg.defaultExpectation == nil {
		mmRecvMsg.defaultExpectation = &Telemetry_StreamLogMessagesServerMockRecvMsgExpectation{mock: mmRecvMsg.mock}
	}
	mmRecvMsg.defaultExpectation.results = &Telemetry_StreamLogMessagesServerMockRecvMsgResults{err}
	return mmRecvMsg.mock
}

// Set uses given function f to mock the Telemetry_StreamLogMessagesServer.RecvMsg method
func (mmRecvMsg *mTelemetry_StreamLogMessagesServerMockRecvMsg) Set(f func(m interface{}) (err error)) *Telemetry_StreamLogMessagesServerMock {
	if mmRecvMsg.defaultExpectation != nil {
		mmRecvMsg.mock.t.Fatalf("Default expectation is already set for the Telemetry_StreamLogMessagesServer.RecvMsg method")
	}

	if len(mmRecvMsg.expectations) > 0 {
		mmRecvMsg.mock.t.Fatalf("Some expectations are already set for the Telemetry_StreamLogMessagesServer.RecvMsg method")
	}

	mmRecvMsg.mock.funcRecvMsg = f
	return mmRecvMsg.mock
}

// When sets expectation for the Telemetry_StreamLogMessagesServer.RecvMsg which will trigger the result defined by the following
// Then helper
func (mmRecvMsg *mTelemetry_StreamLogMessagesServerMockRecvMsg) When(m interface{}) *Telemetry_StreamLogMessagesServerMockRecvMsgExpectation {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.RecvMsg mock is already set by Set")
	}

	expectation := &Telemetry_StreamLogMessagesServerMockRecvMsgExpectation{
		mock:   mmRecvMsg.mock,
		params: &Telemetry_StreamLogMessagesServerMockRecvMsgParams{m},
	}
	mmRecvMsg.expectations = append(mmRecvMsg.expectations, expectation)
	return expectation
}

// Then sets up Telemetry_StreamLogMessagesServer.RecvMsg return parameters for the expectation previously defined by the When method
func (e *Telemetry_StreamLogMessagesServerMockRecvMsgExpectation) Then(err error) *Telemetry_StreamLogMessagesServerMock {
	e.results = &Telemetry_StreamLogMessagesServerMockRecvMsgResults{err}
	return e.mock
}

// RecvMsg implements telemetry.Telemetry_StreamLogMessagesServer
func (mmRecvMsg *Telemetry_StreamLogMessagesServerMock) RecvMsg(m interface{}) (err error) {
	mm_atomic.AddUint64(&mmRecvMsg.beforeRecvMsgCounter, 1)
	defer mm_atomic.AddUint64(&mmRecvMsg.afterRecvMsgCounter, 1)

	if mmRecvMsg.inspectFuncRecvMsg != nil {
		mmRecvMsg.inspectFuncRecvMsg(m)
	}

	mm_params := &Telemetry_StreamLogMessagesServerMockRecvMsgParams{m}

	// Record call args
	mmRecvMsg.RecvMsgMock.mutex.Lock()
	mmRecvMsg.RecvMsgMock.callArgs = append(mmRecvMsg.RecvMsgMock.callArgs, mm_params)
	mmRecvMsg.RecvMsgMock.mutex.Unlock()

	for _, e := range mmRecvMsg.RecvMsgMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRecvMsg.RecvMsgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecvMsg.RecvMsgMock.defaultExpectation.Counter, 1)
		mm_want := mmRecvMsg.RecvMsgMock.defaultExpectation.params
		mm_got := Telemetry_StreamLogMessagesServerMockRecvMsgParams{m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRecvMsg.t.Errorf("Telemetry_StreamLogMessagesServerMock.RecvMsg got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRecvMsg.RecvMsgMock.defaultExpectation.results
		if mm_results == nil {
			mmRecvMsg.t.Fatal("No results are set for the Telemetry_StreamLogMessagesServerMock.RecvMsg")
		}
		return (*mm_results).err
	}
	if mmRecvMsg.funcRecvMsg != nil {
		return mmRecvMsg.funcRecvMsg(m)
	}
	mmRecvMsg.t.Fatalf("Unexpected call to Telemetry_StreamLogMessagesServerMock.RecvMsg. %v", m)
	return
}

// RecvMsgAfterCounter returns a count of finished Telemetry_StreamLogMessagesServerMock.RecvMsg invocations
func (mmRecvMsg *Telemetry_StreamLogMessagesServerMock) RecvMsgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecvMsg.afterRecvMsgCounter)
}

// RecvMsgBeforeCounter returns a count of Telemetry_StreamLogMessagesServerMock.RecvMsg invocations
func (mmRecvMsg *Telemetry_StreamLogMessagesServerMock) RecvMsgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecvMsg.beforeRecvMsgCounter)
}

// Calls returns a list of arguments used in each call to Telemetry_StreamLogMessagesServerMock.RecvMsg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRecvMsg *mTelemetry_StreamLogMessagesServerMockRecvMsg) Calls() []*Telemetry_StreamLogMessagesServerMockRecvMsgParams {
	mmRecvMsg.mutex.RLock()

	argCopy := make([]*Telemetry_StreamLogMessagesServerMockRecvMsgParams, len(mmRecvMsg.callArgs))
	copy(argCopy, mmRecvMsg.callArgs)

	mmRecvMsg.mutex.RUnlock()

	return argCopy
}

// MinimockRecvMsgDone returns true if the count of the RecvMsg invocations corresponds
// the number of defined expectations
func (m *Telemetry_StreamLogMessagesServerMock) MinimockRecvMsgDone() bool {
	for _, e := range m.RecvMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecvMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecvMsg != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		return false
	}
	return true
}

// MinimockRecvMsgInspect logs each unmet expectation
func (m *Telemetry_StreamLogMessagesServerMock) MinimockRecvMsgInspect() {
	for _, e := range m.RecvMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Telemetry_StreamLogMessagesServerMock.RecvMsg with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecvMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		if m.RecvMsgMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.RecvMsg")
		} else {
			m.t.Errorf("Expected call to Telemetry_StreamLogMessagesServerMock.RecvMsg with params: %#v", *m.RecvMsgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecvMsg != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.RecvMsg")
	}
}

type mTelemetry_StreamLogMessagesServerMockSend struct {
	mock               *Telemetry_StreamLogMessagesServerMock
	defaultExpectation *Telemetry_StreamLogMessagesServerMockSendExpectation
	expectations       []*Telemetry_StreamLogMessagesServerMockSendExpectation

	callArgs []*Telemetry_StreamLogMessagesServerMockSendParams
	mutex    sync.RWMutex
}

// Telemetry_StreamLogMessagesServerMockSendExpectation specifies expectation struct of the Telemetry_StreamLogMessagesServer.Send
type Telemetry_StreamLogMessagesServerMockSendExpectation struct {
	mock    *Telemetry_StreamLogMessagesServerMock
	params  *Telemetry_StreamLogMessagesServerMockSendParams
	results *Telemetry_StreamLogMessagesServerMockSendResults
	Counter uint64
}

// Telemetry_StreamLogMessagesServerMockSendParams contains parameters of the Telemetry_StreamLogMessagesServer.Send
type Telemetry_StreamLogMessagesServerMockSendParams struct {
	sp1 *mm_telemetry.StreamLogMessagesResponse
}

// Telemetry_StreamLogMessagesServerMockSendResults contains results of the Telemetry_StreamLogMessagesServer.Send
type Telemetry_StreamLogMessagesServerMockSendResults struct {
	err error
}

// Expect sets up expected params for Telemetry_StreamLogMessagesServer.Send
func (mmSend *mTelemetry_StreamLogMessagesServerMockSend) Expect(sp1 *mm_telemetry.StreamLogMessagesResponse) *mTelemetry_StreamLogMessagesServerMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &Telemetry_StreamLogMessagesServerMockSendExpectation{}
	}

	mmSend.defaultExpectation.params = &Telemetry_StreamLogMessagesServerMockSendParams{sp1}
	for _, e := range mmSend.expectations {
		if minimock.Equal(e.params, mmSend.defaultExpectation.params) {
			mmSend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSend.defaultExpectation.params)
		}
	}

	return mmSend
}

// Inspect accepts an inspector function that has same arguments as the Telemetry_StreamLogMessagesServer.Send
func (mmSend *mTelemetry_StreamLogMessagesServerMockSend) Inspect(f func(sp1 *mm_telemetry.StreamLogMessagesResponse)) *mTelemetry_StreamLogMessagesServerMockSend {
	if mmSend.mock.inspectFuncSend != nil {
		mmSend.mock.t.Fatalf("Inspect function is already set for Telemetry_StreamLogMessagesServerMock.Send")
	}

	mmSend.mock.inspectFuncSend = f

	return mmSend
}

// Return sets up results that will be returned by Telemetry_StreamLogMessagesServer.Send
func (mmSend *mTelemetry_StreamLogMessagesServerMockSend) Return(err error) *Telemetry_StreamLogMessagesServerMock {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &Telemetry_StreamLogMessagesServerMockSendExpectation{mock: mmSend.mock}
	}
	mmSend.defaultExpectation.results = &Telemetry_StreamLogMessagesServerMockSendResults{err}
	return mmSend.mock
}

// Set uses given function f to mock the Telemetry_StreamLogMessagesServer.Send method
func (mmSend *mTelemetry_StreamLogMessagesServerMockSend) Set(f func(sp1 *mm_telemetry.StreamLogMessagesResponse) (err error)) *Telemetry_StreamLogMessagesServerMock {
	if mmSend.defaultExpectation != nil {
		mmSend.mock.t.Fatalf("Default expectation is already set for the Telemetry_StreamLogMessagesServer.Send method")
	}

	if len(mmSend.expectations) > 0 {
		mmSend.mock.t.Fatalf("Some expectations are already set for the Telemetry_StreamLogMessagesServer.Send method")
	}

	mmSend.mock.funcSend = f
	return mmSend.mock
}

// When sets expectation for the Telemetry_StreamLogMessagesServer.Send which will trigger the result defined by the following
// Then helper
func (mmSend *mTelemetry_StreamLogMessagesServerMockSend) When(sp1 *mm_telemetry.StreamLogMessagesResponse) *Telemetry_StreamLogMessagesServerMockSendExpectation {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.Send mock is already set by Set")
	}

	expectation := &Telemetry_StreamLogMessagesServerMockSendExpectation{
		mock:   mmSend.mock,
		params: &Telemetry_StreamLogMessagesServerMockSendParams{sp1},
	}
	mmSend.expectations = append(mmSend.expectations, expectation)
	return expectation
}

// Then sets up Telemetry_StreamLogMessagesServer.Send return parameters for the expectation previously defined by the When method
func (e *Telemetry_StreamLogMessagesServerMockSendExpectation) Then(err error) *Telemetry_StreamLogMessagesServerMock {
	e.results = &Telemetry_StreamLogMessagesServerMockSendResults{err}
	return e.mock
}

// Send implements telemetry.Telemetry_StreamLogMessagesServer
func (mmSend *Telemetry_StreamLogMessagesServerMock) Send(sp1 *mm_telemetry.StreamLogMessagesResponse) (err error) {
	mm_atomic.AddUint64(&mmSend.beforeSendCounter, 1)
	defer mm_atomic.AddUint64(&mmSend.afterSendCounter, 1)

	if mmSend.inspectFuncSend != nil {
		mmSend.inspectFuncSend(sp1)
	}

	mm_params := &Telemetry_StreamLogMessagesServerMockSendParams{sp1}

	// Record call args
	mmSend.SendMock.mutex.Lock()
	mmSend.SendMock.callArgs = append(mmSend.SendMock.callArgs, mm_params)
	mmSend.SendMock.mutex.Unlock()

	for _, e := range mmSend.SendMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSend.SendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSend.SendMock.defaultExpectation.Counter, 1)
		mm_want := mmSend.SendMock.defaultExpectation.params
		mm_got := Telemetry_StreamLogMessagesServerMockSendParams{sp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSend.t.Errorf("Telemetry_StreamLogMessagesServerMock.Send got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSend.SendMock.defaultExpectation.results
		if mm_results == nil {
			mmSend.t.Fatal("No results are set for the Telemetry_StreamLogMessagesServerMock.Send")
		}
		return (*mm_results).err
	}
	if mmSend.funcSend != nil {
		return mmSend.funcSend(sp1)
	}
	mmSend.t.Fatalf("Unexpected call to Telemetry_StreamLogMessagesServerMock.Send. %v", sp1)
	return
}

// SendAfterCounter returns a count of finished Telemetry_StreamLogMessagesServerMock.Send invocations
func (mmSend *Telemetry_StreamLogMessagesServerMock) SendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.afterSendCounter)
}

// SendBeforeCounter returns a count of Telemetry_StreamLogMessagesServerMock.Send invocations
func (mmSend *Telemetry_StreamLogMessagesServerMock) SendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.beforeSendCounter)
}

// Calls returns a list of arguments used in each call to Telemetry_StreamLogMessagesServerMock.Send.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSend *mTelemetry_StreamLogMessagesServerMockSend) Calls() []*Telemetry_StreamLogMessagesServerMockSendParams {
	mmSend.mutex.RLock()

	argCopy := make([]*Telemetry_StreamLogMessagesServerMockSendParams, len(mmSend.callArgs))
	copy(argCopy, mmSend.callArgs)

	mmSend.mutex.RUnlock()

	return argCopy
}

// MinimockSendDone returns true if the count of the Send invocations corresponds
// the number of defined expectations
func (m *Telemetry_StreamLogMessagesServerMock) MinimockSendDone() bool {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendInspect logs each unmet expectation
func (m *Telemetry_StreamLogMessagesServerMock) MinimockSendInspect() {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Telemetry_StreamLogMessagesServerMock.Send with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		if m.SendMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.Send")
		} else {
			m.t.Errorf("Expected call to Telemetry_StreamLogMessagesServerMock.Send with params: %#v", *m.SendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.Send")
	}
}

type mTelemetry_StreamLogMessagesServerMockSendHeader struct {
	mock               *Telemetry_StreamLogMessagesServerMock
	defaultExpectation *Telemetry_StreamLogMessagesServerMockSendHeaderExpectation
	expectations       []*Telemetry_StreamLogMessagesServerMockSendHeaderExpectation

	callArgs []*Telemetry_StreamLogMessagesServerMockSendHeaderParams
	mutex    sync.RWMutex
}

// Telemetry_StreamLogMessagesServerMockSendHeaderExpectation specifies expectation struct of the Telemetry_StreamLogMessagesServer.SendHeader
type Telemetry_StreamLogMessagesServerMockSendHeaderExpectation struct {
	mock    *Telemetry_StreamLogMessagesServerMock
	params  *Telemetry_StreamLogMessagesServerMockSendHeaderParams
	results *Telemetry_StreamLogMessagesServerMockSendHeaderResults
	Counter uint64
}

// Telemetry_StreamLogMessagesServerMockSendHeaderParams contains parameters of the Telemetry_StreamLogMessagesServer.SendHeader
type Telemetry_StreamLogMessagesServerMockSendHeaderParams struct {
	m1 metadata.MD
}

// Telemetry_StreamLogMessagesServerMockSendHeaderResults contains results of the Telemetry_StreamLogMessagesServer.SendHeader
type Telemetry_StreamLogMessagesServerMockSendHeaderResults struct {
	err error
}

// Expect sets up expected params for Telemetry_StreamLogMessagesServer.SendHeader
func (mmSendHeader *mTelemetry_StreamLogMessagesServerMockSendHeader) Expect(m1 metadata.MD) *mTelemetry_StreamLogMessagesServerMockSendHeader {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.SendHeader mock is already set by Set")
	}

	if mmSendHeader.defaultExpectation == nil {
		mmSendHeader.defaultExpectation = &Telemetry_StreamLogMessagesServerMockSendHeaderExpectation{}
	}

	mmSendHeader.defaultExpectation.params = &Telemetry_StreamLogMessagesServerMockSendHeaderParams{m1}
	for _, e := range mmSendHeader.expectations {
		if minimock.Equal(e.params, mmSendHeader.defaultExpectation.params) {
			mmSendHeader.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendHeader.defaultExpectation.params)
		}
	}

	return mmSendHeader
}

// Inspect accepts an inspector function that has same arguments as the Telemetry_StreamLogMessagesServer.SendHeader
func (mmSendHeader *mTelemetry_StreamLogMessagesServerMockSendHeader) Inspect(f func(m1 metadata.MD)) *mTelemetry_StreamLogMessagesServerMockSendHeader {
	if mmSendHeader.mock.inspectFuncSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("Inspect function is already set for Telemetry_StreamLogMessagesServerMock.SendHeader")
	}

	mmSendHeader.mock.inspectFuncSendHeader = f

	return mmSendHeader
}

// Return sets up results that will be returned by Telemetry_StreamLogMessagesServer.SendHeader
func (mmSendHeader *mTelemetry_StreamLogMessagesServerMockSendHeader) Return(err error) *Telemetry_StreamLogMessagesServerMock {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.SendHeader mock is already set by Set")
	}

	if mmSendHeader.defaultExpectation == nil {
		mmSendHeader.defaultExpectation = &Telemetry_StreamLogMessagesServerMockSendHeaderExpectation{mock: mmSendHeader.mock}
	}
	mmSendHeader.defaultExpectation.results = &Telemetry_StreamLogMessagesServerMockSendHeaderResults{err}
	return mmSendHeader.mock
}

// Set uses given function f to mock the Telemetry_StreamLogMessagesServer.SendHeader method
func (mmSendHeader *mTelemetry_StreamLogMessagesServerMockSendHeader) Set(f func(m1 metadata.MD) (err error)) *Telemetry_StreamLogMessagesServerMock {
	if mmSendHeader.defaultExpectation != nil {
		mmSendHeader.mock.t.Fatalf("Default expectation is already set for the Telemetry_StreamLogMessagesServer.SendHeader method")
	}

	if len(mmSendHeader.expectations) > 0 {
		mmSendHeader.mock.t.Fatalf("Some expectations are already set for the Telemetry_StreamLogMessagesServer.SendHeader method")
	}

	mmSendHeader.mock.funcSendHeader = f
	return mmSendHeader.mock
}

// When sets expectation for the Telemetry_StreamLogMessagesServer.SendHeader which will trigger the result defined by the following
// Then helper
func (mmSendHeader *mTelemetry_StreamLogMessagesServerMockSendHeader) When(m1 metadata.MD) *Telemetry_StreamLogMessagesServerMockSendHeaderExpectation {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.SendHeader mock is already set by Set")
	}

	expectation := &Telemetry_StreamLogMessagesServerMockSendHeaderExpectation{
		mock:   mmSendHeader.mock,
		params: &Telemetry_StreamLogMessagesServerMockSendHeaderParams{m1},
	}
	mmSendHeader.expectations = append(mmSendHeader.expectations, expectation)
	return expectation
}

// Then sets up Telemetry_StreamLogMessagesServer.SendHeader return parameters for the expectation previously defined by the When method
func (e *Telemetry_StreamLogMessagesServerMockSendHeaderExpectation) Then(err error) *Telemetry_StreamLogMessagesServerMock {
	e.results = &Telemetry_StreamLogMessagesServerMockSendHeaderResults{err}
	return e.mock
}

// SendHeader implements telemetry.Telemetry_StreamLogMessagesServer
func (mmSendHeader *Telemetry_StreamLogMessagesServerMock) SendHeader(m1 metadata.MD) (err error) {
	mm_atomic.AddUint64(&mmSendHeader.beforeSendHeaderCounter, 1)
	defer mm_atomic.AddUint64(&mmSendHeader.afterSendHeaderCounter, 1)

	if mmSendHeader.inspectFuncSendHeader != nil {
		mmSendHeader.inspectFuncSendHeader(m1)
	}

	mm_params := &Telemetry_StreamLogMessagesServerMockSendHeaderParams{m1}

	// Record call args
	mmSendHeader.SendHeaderMock.mutex.Lock()
	mmSendHeader.SendHeaderMock.callArgs = append(mmSendHeader.SendHeaderMock.callArgs, mm_params)
	mmSendHeader.SendHeaderMock.mutex.Unlock()

	for _, e := range mmSendHeader.SendHeaderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendHeader.SendHeaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendHeader.SendHeaderMock.defaultExpectation.Counter, 1)
		mm_want := mmSendHeader.SendHeaderMock.defaultExpectation.params
		mm_got := Telemetry_StreamLogMessagesServerMockSendHeaderParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendHeader.t.Errorf("Telemetry_StreamLogMessagesServerMock.SendHeader got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendHeader.SendHeaderMock.defaultExpectation.results
		if mm_results == nil {
			mmSendHeader.t.Fatal("No results are set for the Telemetry_StreamLogMessagesServerMock.SendHeader")
		}
		return (*mm_results).err
	}
	if mmSendHeader.funcSendHeader != nil {
		return mmSendHeader.funcSendHeader(m1)
	}
	mmSendHeader.t.Fatalf("Unexpected call to Telemetry_StreamLogMessagesServerMock.SendHeader. %v", m1)
	return
}

// SendHeaderAfterCounter returns a count of finished Telemetry_StreamLogMessagesServerMock.SendHeader invocations
func (mmSendHeader *Telemetry_StreamLogMessagesServerMock) SendHeaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendHeader.afterSendHeaderCounter)
}

// SendHeaderBeforeCounter returns a count of Telemetry_StreamLogMessagesServerMock.SendHeader invocations
func (mmSendHeader *Telemetry_StreamLogMessagesServerMock) SendHeaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendHeader.beforeSendHeaderCounter)
}

// Calls returns a list of arguments used in each call to Telemetry_StreamLogMessagesServerMock.SendHeader.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendHeader *mTelemetry_StreamLogMessagesServerMockSendHeader) Calls() []*Telemetry_StreamLogMessagesServerMockSendHeaderParams {
	mmSendHeader.mutex.RLock()

	argCopy := make([]*Telemetry_StreamLogMessagesServerMockSendHeaderParams, len(mmSendHeader.callArgs))
	copy(argCopy, mmSendHeader.callArgs)

	mmSendHeader.mutex.RUnlock()

	return argCopy
}

// MinimockSendHeaderDone returns true if the count of the SendHeader invocations corresponds
// the number of defined expectations
func (m *Telemetry_StreamLogMessagesServerMock) MinimockSendHeaderDone() bool {
	for _, e := range m.SendHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendHeaderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendHeader != nil && mm_atomic.LoadUint64(&m.afterSendHeaderCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendHeaderInspect logs each unmet expectation
func (m *Telemetry_StreamLogMessagesServerMock) MinimockSendHeaderInspect() {
	for _, e := range m.SendHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Telemetry_StreamLogMessagesServerMock.SendHeader with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendHeaderCounter) < 1 {
		if m.SendHeaderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.SendHeader")
		} else {
			m.t.Errorf("Expected call to Telemetry_StreamLogMessagesServerMock.SendHeader with params: %#v", *m.SendHeaderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendHeader != nil && mm_atomic.LoadUint64(&m.afterSendHeaderCounter) < 1 {
		m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.SendHeader")
	}
}

type mTelemetry_StreamLogMessagesServerMockSendMsg struct {
	mock               *Telemetry_StreamLogMessagesServerMock
	defaultExpectation *Telemetry_StreamLogMessagesServerMockSendMsgExpectation
	expectations       []*Telemetry_StreamLogMessagesServerMockSendMsgExpectation

	callArgs []*Telemetry_StreamLogMessagesServerMockSendMsgParams
	mutex    sync.RWMutex
}

// Telemetry_StreamLogMessagesServerMockSendMsgExpectation specifies expectation struct of the Telemetry_StreamLogMessagesServer.SendMsg
type Telemetry_StreamLogMessagesServerMockSendMsgExpectation struct {
	mock    *Telemetry_StreamLogMessagesServerMock
	params  *Telemetry_StreamLogMessagesServerMockSendMsgParams
	results *Telemetry_StreamLogMessagesServerMockSendMsgResults
	Counter uint64
}

// Telemetry_StreamLogMessagesServerMockSendMsgParams contains parameters of the Telemetry_StreamLogMessagesServer.SendMsg
type Telemetry_StreamLogMessagesServerMockSendMsgParams struct {
	m interface{}
}

// Telemetry_StreamLogMessagesServerMockSendMsgResults contains results of the Telemetry_StreamLogMessagesServer.SendMsg
type Telemetry_StreamLogMessagesServerMockSendMsgResults struct {
	err error
}

// Expect sets up expected params for Telemetry_StreamLogMessagesServer.SendMsg
func (mmSendMsg *mTelemetry_StreamLogMessagesServerMockSendMsg) Expect(m interface{}) *mTelemetry_StreamLogMessagesServerMockSendMsg {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &Telemetry_StreamLogMessagesServerMockSendMsgExpectation{}
	}

	mmSendMsg.defaultExpectation.params = &Telemetry_StreamLogMessagesServerMockSendMsgParams{m}
	for _, e := range mmSendMsg.expectations {
		if minimock.Equal(e.params, mmSendMsg.defaultExpectation.params) {
			mmSendMsg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMsg.defaultExpectation.params)
		}
	}

	return mmSendMsg
}

// Inspect accepts an inspector function that has same arguments as the Telemetry_StreamLogMessagesServer.SendMsg
func (mmSendMsg *mTelemetry_StreamLogMessagesServerMockSendMsg) Inspect(f func(m interface{})) *mTelemetry_StreamLogMessagesServerMockSendMsg {
	if mmSendMsg.mock.inspectFuncSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("Inspect function is already set for Telemetry_StreamLogMessagesServerMock.SendMsg")
	}

	mmSendMsg.mock.inspectFuncSendMsg = f

	return mmSendMsg
}

// Return sets up results that will be returned by Telemetry_StreamLogMessagesServer.SendMsg
func (mmSendMsg *mTelemetry_StreamLogMessagesServerMockSendMsg) Return(err error) *Telemetry_StreamLogMessagesServerMock {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &Telemetry_StreamLogMessagesServerMockSendMsgExpectation{mock: mmSendMsg.mock}
	}
	mmSendMsg.defaultExpectation.results = &Telemetry_StreamLogMessagesServerMockSendMsgResults{err}
	return mmSendMsg.mock
}

// Set uses given function f to mock the Telemetry_StreamLogMessagesServer.SendMsg method
func (mmSendMsg *mTelemetry_StreamLogMessagesServerMockSendMsg) Set(f func(m interface{}) (err error)) *Telemetry_StreamLogMessagesServerMock {
	if mmSendMsg.defaultExpectation != nil {
		mmSendMsg.mock.t.Fatalf("Default expectation is already set for the Telemetry_StreamLogMessagesServer.SendMsg method")
	}

	if len(mmSendMsg.expectations) > 0 {
		mmSendMsg.mock.t.Fatalf("Some expectations are already set for the Telemetry_StreamLogMessagesServer.SendMsg method")
	}

	mmSendMsg.mock.funcSendMsg = f
	return mmSendMsg.mock
}

// When sets expectation for the Telemetry_StreamLogMessagesServer.SendMsg which will trigger the result defined by the following
// Then helper
func (mmSendMsg *mTelemetry_StreamLogMessagesServerMockSendMsg) When(m interface{}) *Telemetry_StreamLogMessagesServerMockSendMsgExpectation {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.SendMsg mock is already set by Set")
	}

	expectation := &Telemetry_StreamLogMessagesServerMockSendMsgExpectation{
		mock:   mmSendMsg.mock,
		params: &Telemetry_StreamLogMessagesServerMockSendMsgParams{m},
	}
	mmSendMsg.expectations = append(mmSendMsg.expectations, expectation)
	return expectation
}

// Then sets up Telemetry_StreamLogMessagesServer.SendMsg return parameters for the expectation previously defined by the When method
func (e *Telemetry_StreamLogMessagesServerMockSendMsgExpectation) Then(err error) *Telemetry_StreamLogMessagesServerMock {
	e.results = &Telemetry_StreamLogMessagesServerMockSendMsgResults{err}
	return e.mock
}

// SendMsg implements telemetry.Telemetry_StreamLogMessagesServer
func (mmSendMsg *Telemetry_StreamLogMessagesServerMock) SendMsg(m interface{}) (err error) {
	mm_atomic.AddUint64(&mmSendMsg.beforeSendMsgCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMsg.afterSendMsgCounter, 1)

	if mmSendMsg.inspectFuncSendMsg != nil {
		mmSendMsg.inspectFuncSendMsg(m)
	}

	mm_params := &Telemetry_StreamLogMessagesServerMockSendMsgParams{m}

	// Record call args
	mmSendMsg.SendMsgMock.mutex.Lock()
	mmSendMsg.SendMsgMock.callArgs = append(mmSendMsg.SendMsgMock.callArgs, mm_params)
	mmSendMsg.SendMsgMock.mutex.Unlock()

	for _, e := range mmSendMsg.SendMsgMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMsg.SendMsgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMsg.SendMsgMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMsg.SendMsgMock.defaultExpectation.params
		mm_got := Telemetry_StreamLogMessagesServerMockSendMsgParams{m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMsg.t.Errorf("Telemetry_StreamLogMessagesServerMock.SendMsg got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMsg.SendMsgMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMsg.t.Fatal("No results are set for the Telemetry_StreamLogMessagesServerMock.SendMsg")
		}
		return (*mm_results).err
	}
	if mmSendMsg.funcSendMsg != nil {
		return mmSendMsg.funcSendMsg(m)
	}
	mmSendMsg.t.Fatalf("Unexpected call to Telemetry_StreamLogMessagesServerMock.SendMsg. %v", m)
	return
}

// SendMsgAfterCounter returns a count of finished Telemetry_StreamLogMessagesServerMock.SendMsg invocations
func (mmSendMsg *Telemetry_StreamLogMessagesServerMock) SendMsgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMsg.afterSendMsgCounter)
}

// SendMsgBeforeCounter returns a count of Telemetry_StreamLogMessagesServerMock.SendMsg invocations
func (mmSendMsg *Telemetry_StreamLogMessagesServerMock) SendMsgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMsg.beforeSendMsgCounter)
}

// Calls returns a list of arguments used in each call to Telemetry_StreamLogMessagesServerMock.SendMsg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMsg *mTelemetry_StreamLogMessagesServerMockSendMsg) Calls() []*Telemetry_StreamLogMessagesServerMockSendMsgParams {
	mmSendMsg.mutex.RLock()

	argCopy := make([]*Telemetry_StreamLogMessagesServerMockSendMsgParams, len(mmSendMsg.callArgs))
	copy(argCopy, mmSendMsg.callArgs)

	mmSendMsg.mutex.RUnlock()

	return argCopy
}

// MinimockSendMsgDone returns true if the count of the SendMsg invocations corresponds
// the number of defined expectations
func (m *Telemetry_StreamLogMessagesServerMock) MinimockSendMsgDone() bool {
	for _, e := range m.SendMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMsg != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMsgInspect logs each unmet expectation
func (m *Telemetry_StreamLogMessagesServerMock) MinimockSendMsgInspect() {
	for _, e := range m.SendMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Telemetry_StreamLogMessagesServerMock.SendMsg with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		if m.SendMsgMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.SendMsg")
		} else {
			m.t.Errorf("Expected call to Telemetry_StreamLogMessagesServerMock.SendMsg with params: %#v", *m.SendMsgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMsg != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.SendMsg")
	}
}

type mTelemetry_StreamLogMessagesServerMockSetHeader struct {
	mock               *Telemetry_StreamLogMessagesServerMock
	defaultExpectation *Telemetry_StreamLogMessagesServerMockSetHeaderExpectation
	expectations       []*Telemetry_StreamLogMessagesServerMockSetHeaderExpectation

	callArgs []*Telemetry_StreamLogMessagesServerMockSetHeaderParams
	mutex    sync.RWMutex
}

// Telemetry_StreamLogMessagesServerMockSetHeaderExpectation specifies expectation struct of the Telemetry_StreamLogMessagesServer.SetHeader
type Telemetry_StreamLogMessagesServerMockSetHeaderExpectation struct {
	mock    *Telemetry_StreamLogMessagesServerMock
	params  *Telemetry_StreamLogMessagesServerMockSetHeaderParams
	results *Telemetry_StreamLogMessagesServerMockSetHeaderResults
	Counter uint64
}

// Telemetry_StreamLogMessagesServerMockSetHeaderParams contains parameters of the Telemetry_StreamLogMessagesServer.SetHeader
type Telemetry_StreamLogMessagesServerMockSetHeaderParams struct {
	m1 metadata.MD
}

// Telemetry_StreamLogMessagesServerMockSetHeaderResults contains results of the Telemetry_StreamLogMessagesServer.SetHeader
type Telemetry_StreamLogMessagesServerMockSetHeaderResults struct {
	err error
}

// Expect sets up expected params for Telemetry_StreamLogMessagesServer.SetHeader
func (mmSetHeader *mTelemetry_StreamLogMessagesServerMockSetHeader) Expect(m1 metadata.MD) *mTelemetry_StreamLogMessagesServerMockSetHeader {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.SetHeader mock is already set by Set")
	}

	if mmSetHeader.defaultExpectation == nil {
		mmSetHeader.defaultExpectation = &Telemetry_StreamLogMessagesServerMockSetHeaderExpectation{}
	}

	mmSetHeader.defaultExpectation.params = &Telemetry_StreamLogMessagesServerMockSetHeaderParams{m1}
	for _, e := range mmSetHeader.expectations {
		if minimock.Equal(e.params, mmSetHeader.defaultExpectation.params) {
			mmSetHeader.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetHeader.defaultExpectation.params)
		}
	}

	return mmSetHeader
}

// Inspect accepts an inspector function that has same arguments as the Telemetry_StreamLogMessagesServer.SetHeader
func (mmSetHeader *mTelemetry_StreamLogMessagesServerMockSetHeader) Inspect(f func(m1 metadata.MD)) *mTelemetry_StreamLogMessagesServerMockSetHeader {
	if mmSetHeader.mock.inspectFuncSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("Inspect function is already set for Telemetry_StreamLogMessagesServerMock.SetHeader")
	}

	mmSetHeader.mock.inspectFuncSetHeader = f

	return mmSetHeader
}

// Return sets up results that will be returned by Telemetry_StreamLogMessagesServer.SetHeader
func (mmSetHeader *mTelemetry_StreamLogMessagesServerMockSetHeader) Return(err error) *Telemetry_StreamLogMessagesServerMock {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.SetHeader mock is already set by Set")
	}

	if mmSetHeader.defaultExpectation == nil {
		mmSetHeader.defaultExpectation = &Telemetry_StreamLogMessagesServerMockSetHeaderExpectation{mock: mmSetHeader.mock}
	}
	mmSetHeader.defaultExpectation.results = &Telemetry_StreamLogMessagesServerMockSetHeaderResults{err}
	return mmSetHeader.mock
}

// Set uses given function f to mock the Telemetry_StreamLogMessagesServer.SetHeader method
func (mmSetHeader *mTelemetry_StreamLogMessagesServerMockSetHeader) Set(f func(m1 metadata.MD) (err error)) *Telemetry_StreamLogMessagesServerMock {
	if mmSetHeader.defaultExpectation != nil {
		mmSetHeader.mock.t.Fatalf("Default expectation is already set for the Telemetry_StreamLogMessagesServer.SetHeader method")
	}

	if len(mmSetHeader.expectations) > 0 {
		mmSetHeader.mock.t.Fatalf("Some expectations are already set for the Telemetry_StreamLogMessagesServer.SetHeader method")
	}

	mmSetHeader.mock.funcSetHeader = f
	return mmSetHeader.mock
}

// When sets expectation for the Telemetry_StreamLogMessagesServer.SetHeader which will trigger the result defined by the following
// Then helper
func (mmSetHeader *mTelemetry_StreamLogMessagesServerMockSetHeader) When(m1 metadata.MD) *Telemetry_StreamLogMessagesServerMockSetHeaderExpectation {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.SetHeader mock is already set by Set")
	}

	expectation := &Telemetry_StreamLogMessagesServerMockSetHeaderExpectation{
		mock:   mmSetHeader.mock,
		params: &Telemetry_StreamLogMessagesServerMockSetHeaderParams{m1},
	}
	mmSetHeader.expectations = append(mmSetHeader.expectations, expectation)
	return expectation
}

// Then sets up Telemetry_StreamLogMessagesServer.SetHeader return parameters for the expectation previously defined by the When method
func (e *Telemetry_StreamLogMessagesServerMockSetHeaderExpectation) Then(err error) *Telemetry_StreamLogMessagesServerMock {
	e.results = &Telemetry_StreamLogMessagesServerMockSetHeaderResults{err}
	return e.mock
}

// SetHeader implements telemetry.Telemetry_StreamLogMessagesServer
func (mmSetHeader *Telemetry_StreamLogMessagesServerMock) SetHeader(m1 metadata.MD) (err error) {
	mm_atomic.AddUint64(&mmSetHeader.beforeSetHeaderCounter, 1)
	defer mm_atomic.AddUint64(&mmSetHeader.afterSetHeaderCounter, 1)

	if mmSetHeader.inspectFuncSetHeader != nil {
		mmSetHeader.inspectFuncSetHeader(m1)
	}

	mm_params := &Telemetry_StreamLogMessagesServerMockSetHeaderParams{m1}

	// Record call args
	mmSetHeader.SetHeaderMock.mutex.Lock()
	mmSetHeader.SetHeaderMock.callArgs = append(mmSetHeader.SetHeaderMock.callArgs, mm_params)
	mmSetHeader.SetHeaderMock.mutex.Unlock()

	for _, e := range mmSetHeader.SetHeaderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetHeader.SetHeaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetHeader.SetHeaderMock.defaultExpectation.Counter, 1)
		mm_want := mmSetHeader.SetHeaderMock.defaultExpectation.params
		mm_got := Telemetry_StreamLogMessagesServerMockSetHeaderParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetHeader.t.Errorf("Telemetry_StreamLogMessagesServerMock.SetHeader got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetHeader.SetHeaderMock.defaultExpectation.results
		if mm_results == nil {
			mmSetHeader.t.Fatal("No results are set for the Telemetry_StreamLogMessagesServerMock.SetHeader")
		}
		return (*mm_results).err
	}
	if mmSetHeader.funcSetHeader != nil {
		return mmSetHeader.funcSetHeader(m1)
	}
	mmSetHeader.t.Fatalf("Unexpected call to Telemetry_StreamLogMessagesServerMock.SetHeader. %v", m1)
	return
}

// SetHeaderAfterCounter returns a count of finished Telemetry_StreamLogMessagesServerMock.SetHeader invocations
func (mmSetHeader *Telemetry_StreamLogMessagesServerMock) SetHeaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetHeader.afterSetHeaderCounter)
}

// SetHeaderBeforeCounter returns a count of Telemetry_StreamLogMessagesServerMock.SetHeader invocations
func (mmSetHeader *Telemetry_StreamLogMessagesServerMock) SetHeaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetHeader.beforeSetHeaderCounter)
}

// Calls returns a list of arguments used in each call to Telemetry_StreamLogMessagesServerMock.SetHeader.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetHeader *mTelemetry_StreamLogMessagesServerMockSetHeader) Calls() []*Telemetry_StreamLogMessagesServerMockSetHeaderParams {
	mmSetHeader.mutex.RLock()

	argCopy := make([]*Telemetry_StreamLogMessagesServerMockSetHeaderParams, len(mmSetHeader.callArgs))
	copy(argCopy, mmSetHeader.callArgs)

	mmSetHeader.mutex.RUnlock()

	return argCopy
}

// MinimockSetHeaderDone returns true if the count of the SetHeader invocations corresponds
// the number of defined expectations
func (m *Telemetry_StreamLogMessagesServerMock) MinimockSetHeaderDone() bool {
	for _, e := range m.SetHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetHeaderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetHeader != nil && mm_atomic.LoadUint64(&m.afterSetHeaderCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetHeaderInspect logs each unmet expectation
func (m *Telemetry_StreamLogMessagesServerMock) MinimockSetHeaderInspect() {
	for _, e := range m.SetHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Telemetry_StreamLogMessagesServerMock.SetHeader with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetHeaderCounter) < 1 {
		if m.SetHeaderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.SetHeader")
		} else {
			m.t.Errorf("Expected call to Telemetry_StreamLogMessagesServerMock.SetHeader with params: %#v", *m.SetHeaderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetHeader != nil && mm_atomic.LoadUint64(&m.afterSetHeaderCounter) < 1 {
		m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.SetHeader")
	}
}

type mTelemetry_StreamLogMessagesServerMockSetTrailer struct {
	mock               *Telemetry_StreamLogMessagesServerMock
	defaultExpectation *Telemetry_StreamLogMessagesServerMockSetTrailerExpectation
	expectations       []*Telemetry_StreamLogMessagesServerMockSetTrailerExpectation

	callArgs []*Telemetry_StreamLogMessagesServerMockSetTrailerParams
	mutex    sync.RWMutex
}

// Telemetry_StreamLogMessagesServerMockSetTrailerExpectation specifies expectation struct of the Telemetry_StreamLogMessagesServer.SetTrailer
type Telemetry_StreamLogMessagesServerMockSetTrailerExpectation struct {
	mock   *Telemetry_StreamLogMessagesServerMock
	params *Telemetry_StreamLogMessagesServerMockSetTrailerParams

	Counter uint64
}

// Telemetry_StreamLogMessagesServerMockSetTrailerParams contains parameters of the Telemetry_StreamLogMessagesServer.SetTrailer
type Telemetry_StreamLogMessagesServerMockSetTrailerParams struct {
	m1 metadata.MD
}

// Expect sets up expected params for Telemetry_StreamLogMessagesServer.SetTrailer
func (mmSetTrailer *mTelemetry_StreamLogMessagesServerMockSetTrailer) Expect(m1 metadata.MD) *mTelemetry_StreamLogMessagesServerMockSetTrailer {
	if mmSetTrailer.mock.funcSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.SetTrailer mock is already set by Set")
	}

	if mmSetTrailer.defaultExpectation == nil {
		mmSetTrailer.defaultExpectation = &Telemetry_StreamLogMessagesServerMockSetTrailerExpectation{}
	}

	mmSetTrailer.defaultExpectation.params = &Telemetry_StreamLogMessagesServerMockSetTrailerParams{m1}
	for _, e := range mmSetTrailer.expectations {
		if minimock.Equal(e.params, mmSetTrailer.defaultExpectation.params) {
			mmSetTrailer.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetTrailer.defaultExpectation.params)
		}
	}

	return mmSetTrailer
}

// Inspect accepts an inspector function that has same arguments as the Telemetry_StreamLogMessagesServer.SetTrailer
func (mmSetTrailer *mTelemetry_StreamLogMessagesServerMockSetTrailer) Inspect(f func(m1 metadata.MD)) *mTelemetry_StreamLogMessagesServerMockSetTrailer {
	if mmSetTrailer.mock.inspectFuncSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("Inspect function is already set for Telemetry_StreamLogMessagesServerMock.SetTrailer")
	}

	mmSetTrailer.mock.inspectFuncSetTrailer = f

	return mmSetTrailer
}

// Return sets up results that will be returned by Telemetry_StreamLogMessagesServer.SetTrailer
func (mmSetTrailer *mTelemetry_StreamLogMessagesServerMockSetTrailer) Return() *Telemetry_StreamLogMessagesServerMock {
	if mmSetTrailer.mock.funcSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("Telemetry_StreamLogMessagesServerMock.SetTrailer mock is already set by Set")
	}

	if mmSetTrailer.defaultExpectation == nil {
		mmSetTrailer.defaultExpectation = &Telemetry_StreamLogMessagesServerMockSetTrailerExpectation{mock: mmSetTrailer.mock}
	}

	return mmSetTrailer.mock
}

// Set uses given function f to mock the Telemetry_StreamLogMessagesServer.SetTrailer method
func (mmSetTrailer *mTelemetry_StreamLogMessagesServerMockSetTrailer) Set(f func(m1 metadata.MD)) *Telemetry_StreamLogMessagesServerMock {
	if mmSetTrailer.defaultExpectation != nil {
		mmSetTrailer.mock.t.Fatalf("Default expectation is already set for the Telemetry_StreamLogMessagesServer.SetTrailer method")
	}

	if len(mmSetTrailer.expectations) > 0 {
		mmSetTrailer.mock.t.Fatalf("Some expectations are already set for the Telemetry_StreamLogMessagesServer.SetTrailer method")
	}

	mmSetTrailer.mock.funcSetTrailer = f
	return mmSetTrailer.mock
}

// SetTrailer implements telemetry.Telemetry_StreamLogMessagesServer
func (mmSetTrailer *Telemetry_StreamLogMessagesServerMock) SetTrailer(m1 metadata.MD) {
	mm_atomic.AddUint64(&mmSetTrailer.beforeSetTrailerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetTrailer.afterSetTrailerCounter, 1)

	if mmSetTrailer.inspectFuncSetTrailer != nil {
		mmSetTrailer.inspectFuncSetTrailer(m1)
	}

	mm_params := &Telemetry_StreamLogMessagesServerMockSetTrailerParams{m1}

	// Record call args
	mmSetTrailer.SetTrailerMock.mutex.Lock()
	mmSetTrailer.SetTrailerMock.callArgs = append(mmSetTrailer.SetTrailerMock.callArgs, mm_params)
	mmSetTrailer.SetTrailerMock.mutex.Unlock()

	for _, e := range mmSetTrailer.SetTrailerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetTrailer.SetTrailerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetTrailer.SetTrailerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetTrailer.SetTrailerMock.defaultExpectation.params
		mm_got := Telemetry_StreamLogMessagesServerMockSetTrailerParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetTrailer.t.Errorf("Telemetry_StreamLogMessagesServerMock.SetTrailer got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetTrailer.funcSetTrailer != nil {
		mmSetTrailer.funcSetTrailer(m1)
		return
	}
	mmSetTrailer.t.Fatalf("Unexpected call to Telemetry_StreamLogMessagesServerMock.SetTrailer. %v", m1)

}

// SetTrailerAfterCounter returns a count of finished Telemetry_StreamLogMessagesServerMock.SetTrailer invocations
func (mmSetTrailer *Telemetry_StreamLogMessagesServerMock) SetTrailerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTrailer.afterSetTrailerCounter)
}

// SetTrailerBeforeCounter returns a count of Telemetry_StreamLogMessagesServerMock.SetTrailer invocations
func (mmSetTrailer *Telemetry_StreamLogMessagesServerMock) SetTrailerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTrailer.beforeSetTrailerCounter)
}

// Calls returns a list of arguments used in each call to Telemetry_StreamLogMessagesServerMock.SetTrailer.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetTrailer *mTelemetry_StreamLogMessagesServerMockSetTrailer) Calls() []*Telemetry_StreamLogMessagesServerMockSetTrailerParams {
	mmSetTrailer.mutex.RLock()

	argCopy := make([]*Telemetry_StreamLogMessagesServerMockSetTrailerParams, len(mmSetTrailer.callArgs))
	copy(argCopy, mmSetTrailer.callArgs)

	mmSetTrailer.mutex.RUnlock()

	return argCopy
}

// MinimockSetTrailerDone returns true if the count of the SetTrailer invocations corresponds
// the number of defined expectations
func (m *Telemetry_StreamLogMessagesServerMock) MinimockSetTrailerDone() bool {
	for _, e := range m.SetTrailerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTrailerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTrailerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTrailer != nil && mm_atomic.LoadUint64(&m.afterSetTrailerCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetTrailerInspect logs each unmet expectation
func (m *Telemetry_StreamLogMessagesServerMock) MinimockSetTrailerInspect() {
	for _, e := range m.SetTrailerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Telemetry_StreamLogMessagesServerMock.SetTrailer with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTrailerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTrailerCounter) < 1 {
		if m.SetTrailerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.SetTrailer")
		} else {
			m.t.Errorf("Expected call to Telemetry_StreamLogMessagesServerMock.SetTrailer with params: %#v", *m.SetTrailerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTrailer != nil && mm_atomic.LoadUint64(&m.afterSetTrailerCounter) < 1 {
		m.t.Error("Expected call to Telemetry_StreamLogMessagesServerMock.SetTrailer")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *Telemetry_StreamLogMessagesServerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockContextInspect()

		m.MinimockRecvMsgInspect()

		m.MinimockSendInspect()

		m.MinimockSendHeaderInspect()

		m.MinimockSendMsgInspect()

		m.MinimockSetHeaderInspect()

		m.MinimockSetTrailerInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *Telemetry_StreamLogMessagesServerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *Telemetry_StreamLogMessagesServerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockContextDone() &&
		m.MinimockRecvMsgDone() &&
		m.MinimockSendDone() &&
		m.MinimockSendHeaderDone() &&
		m.MinimockSendMsgDone() &&
		m.MinimockSetHeaderDone() &&
		m.MinimockSetTrailerDone()
}
