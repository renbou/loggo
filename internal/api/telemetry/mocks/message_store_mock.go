package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/renbou/loggo/internal/api/telemetry.messageStore -o ./message_store_mock.go -n MessageStoreMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/renbou/loggo/internal/storage"
)

// MessageStoreMock implements telemetry.messageStore
type MessageStoreMock struct {
	t minimock.Tester

	funcListMessages          func(from time.Time, to time.Time, filter storage.Filter, after []byte, limit uint) (b1 storage.Batch, err error)
	inspectFuncListMessages   func(from time.Time, to time.Time, filter storage.Filter, after []byte, limit uint)
	afterListMessagesCounter  uint64
	beforeListMessagesCounter uint64
	ListMessagesMock          mMessageStoreMockListMessages

	funcStreamMessages          func(ctx context.Context, from time.Time, filter storage.Filter, limit uint) (b1 storage.Batch, ch1 chan storage.Message, err error)
	inspectFuncStreamMessages   func(ctx context.Context, from time.Time, filter storage.Filter, limit uint)
	afterStreamMessagesCounter  uint64
	beforeStreamMessagesCounter uint64
	StreamMessagesMock          mMessageStoreMockStreamMessages
}

// NewMessageStoreMock returns a mock for telemetry.messageStore
func NewMessageStoreMock(t minimock.Tester) *MessageStoreMock {
	m := &MessageStoreMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ListMessagesMock = mMessageStoreMockListMessages{mock: m}
	m.ListMessagesMock.callArgs = []*MessageStoreMockListMessagesParams{}

	m.StreamMessagesMock = mMessageStoreMockStreamMessages{mock: m}
	m.StreamMessagesMock.callArgs = []*MessageStoreMockStreamMessagesParams{}

	return m
}

type mMessageStoreMockListMessages struct {
	mock               *MessageStoreMock
	defaultExpectation *MessageStoreMockListMessagesExpectation
	expectations       []*MessageStoreMockListMessagesExpectation

	callArgs []*MessageStoreMockListMessagesParams
	mutex    sync.RWMutex
}

// MessageStoreMockListMessagesExpectation specifies expectation struct of the messageStore.ListMessages
type MessageStoreMockListMessagesExpectation struct {
	mock    *MessageStoreMock
	params  *MessageStoreMockListMessagesParams
	results *MessageStoreMockListMessagesResults
	Counter uint64
}

// MessageStoreMockListMessagesParams contains parameters of the messageStore.ListMessages
type MessageStoreMockListMessagesParams struct {
	from   time.Time
	to     time.Time
	filter storage.Filter
	after  []byte
	limit  uint
}

// MessageStoreMockListMessagesResults contains results of the messageStore.ListMessages
type MessageStoreMockListMessagesResults struct {
	b1  storage.Batch
	err error
}

// Expect sets up expected params for messageStore.ListMessages
func (mmListMessages *mMessageStoreMockListMessages) Expect(from time.Time, to time.Time, filter storage.Filter, after []byte, limit uint) *mMessageStoreMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("MessageStoreMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &MessageStoreMockListMessagesExpectation{}
	}

	mmListMessages.defaultExpectation.params = &MessageStoreMockListMessagesParams{from, to, filter, after, limit}
	for _, e := range mmListMessages.expectations {
		if minimock.Equal(e.params, mmListMessages.defaultExpectation.params) {
			mmListMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListMessages.defaultExpectation.params)
		}
	}

	return mmListMessages
}

// Inspect accepts an inspector function that has same arguments as the messageStore.ListMessages
func (mmListMessages *mMessageStoreMockListMessages) Inspect(f func(from time.Time, to time.Time, filter storage.Filter, after []byte, limit uint)) *mMessageStoreMockListMessages {
	if mmListMessages.mock.inspectFuncListMessages != nil {
		mmListMessages.mock.t.Fatalf("Inspect function is already set for MessageStoreMock.ListMessages")
	}

	mmListMessages.mock.inspectFuncListMessages = f

	return mmListMessages
}

// Return sets up results that will be returned by messageStore.ListMessages
func (mmListMessages *mMessageStoreMockListMessages) Return(b1 storage.Batch, err error) *MessageStoreMock {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("MessageStoreMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &MessageStoreMockListMessagesExpectation{mock: mmListMessages.mock}
	}
	mmListMessages.defaultExpectation.results = &MessageStoreMockListMessagesResults{b1, err}
	return mmListMessages.mock
}

// Set uses given function f to mock the messageStore.ListMessages method
func (mmListMessages *mMessageStoreMockListMessages) Set(f func(from time.Time, to time.Time, filter storage.Filter, after []byte, limit uint) (b1 storage.Batch, err error)) *MessageStoreMock {
	if mmListMessages.defaultExpectation != nil {
		mmListMessages.mock.t.Fatalf("Default expectation is already set for the messageStore.ListMessages method")
	}

	if len(mmListMessages.expectations) > 0 {
		mmListMessages.mock.t.Fatalf("Some expectations are already set for the messageStore.ListMessages method")
	}

	mmListMessages.mock.funcListMessages = f
	return mmListMessages.mock
}

// When sets expectation for the messageStore.ListMessages which will trigger the result defined by the following
// Then helper
func (mmListMessages *mMessageStoreMockListMessages) When(from time.Time, to time.Time, filter storage.Filter, after []byte, limit uint) *MessageStoreMockListMessagesExpectation {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("MessageStoreMock.ListMessages mock is already set by Set")
	}

	expectation := &MessageStoreMockListMessagesExpectation{
		mock:   mmListMessages.mock,
		params: &MessageStoreMockListMessagesParams{from, to, filter, after, limit},
	}
	mmListMessages.expectations = append(mmListMessages.expectations, expectation)
	return expectation
}

// Then sets up messageStore.ListMessages return parameters for the expectation previously defined by the When method
func (e *MessageStoreMockListMessagesExpectation) Then(b1 storage.Batch, err error) *MessageStoreMock {
	e.results = &MessageStoreMockListMessagesResults{b1, err}
	return e.mock
}

// ListMessages implements telemetry.messageStore
func (mmListMessages *MessageStoreMock) ListMessages(from time.Time, to time.Time, filter storage.Filter, after []byte, limit uint) (b1 storage.Batch, err error) {
	mm_atomic.AddUint64(&mmListMessages.beforeListMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmListMessages.afterListMessagesCounter, 1)

	if mmListMessages.inspectFuncListMessages != nil {
		mmListMessages.inspectFuncListMessages(from, to, filter, after, limit)
	}

	mm_params := &MessageStoreMockListMessagesParams{from, to, filter, after, limit}

	// Record call args
	mmListMessages.ListMessagesMock.mutex.Lock()
	mmListMessages.ListMessagesMock.callArgs = append(mmListMessages.ListMessagesMock.callArgs, mm_params)
	mmListMessages.ListMessagesMock.mutex.Unlock()

	for _, e := range mmListMessages.ListMessagesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmListMessages.ListMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListMessages.ListMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmListMessages.ListMessagesMock.defaultExpectation.params
		mm_got := MessageStoreMockListMessagesParams{from, to, filter, after, limit}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListMessages.t.Errorf("MessageStoreMock.ListMessages got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListMessages.ListMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmListMessages.t.Fatal("No results are set for the MessageStoreMock.ListMessages")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmListMessages.funcListMessages != nil {
		return mmListMessages.funcListMessages(from, to, filter, after, limit)
	}
	mmListMessages.t.Fatalf("Unexpected call to MessageStoreMock.ListMessages. %v %v %v %v %v", from, to, filter, after, limit)
	return
}

// ListMessagesAfterCounter returns a count of finished MessageStoreMock.ListMessages invocations
func (mmListMessages *MessageStoreMock) ListMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListMessages.afterListMessagesCounter)
}

// ListMessagesBeforeCounter returns a count of MessageStoreMock.ListMessages invocations
func (mmListMessages *MessageStoreMock) ListMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListMessages.beforeListMessagesCounter)
}

// Calls returns a list of arguments used in each call to MessageStoreMock.ListMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListMessages *mMessageStoreMockListMessages) Calls() []*MessageStoreMockListMessagesParams {
	mmListMessages.mutex.RLock()

	argCopy := make([]*MessageStoreMockListMessagesParams, len(mmListMessages.callArgs))
	copy(argCopy, mmListMessages.callArgs)

	mmListMessages.mutex.RUnlock()

	return argCopy
}

// MinimockListMessagesDone returns true if the count of the ListMessages invocations corresponds
// the number of defined expectations
func (m *MessageStoreMock) MinimockListMessagesDone() bool {
	for _, e := range m.ListMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMessagesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListMessagesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListMessages != nil && mm_atomic.LoadUint64(&m.afterListMessagesCounter) < 1 {
		return false
	}
	return true
}

// MinimockListMessagesInspect logs each unmet expectation
func (m *MessageStoreMock) MinimockListMessagesInspect() {
	for _, e := range m.ListMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageStoreMock.ListMessages with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMessagesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListMessagesCounter) < 1 {
		if m.ListMessagesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageStoreMock.ListMessages")
		} else {
			m.t.Errorf("Expected call to MessageStoreMock.ListMessages with params: %#v", *m.ListMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListMessages != nil && mm_atomic.LoadUint64(&m.afterListMessagesCounter) < 1 {
		m.t.Error("Expected call to MessageStoreMock.ListMessages")
	}
}

type mMessageStoreMockStreamMessages struct {
	mock               *MessageStoreMock
	defaultExpectation *MessageStoreMockStreamMessagesExpectation
	expectations       []*MessageStoreMockStreamMessagesExpectation

	callArgs []*MessageStoreMockStreamMessagesParams
	mutex    sync.RWMutex
}

// MessageStoreMockStreamMessagesExpectation specifies expectation struct of the messageStore.StreamMessages
type MessageStoreMockStreamMessagesExpectation struct {
	mock    *MessageStoreMock
	params  *MessageStoreMockStreamMessagesParams
	results *MessageStoreMockStreamMessagesResults
	Counter uint64
}

// MessageStoreMockStreamMessagesParams contains parameters of the messageStore.StreamMessages
type MessageStoreMockStreamMessagesParams struct {
	ctx    context.Context
	from   time.Time
	filter storage.Filter
	limit  uint
}

// MessageStoreMockStreamMessagesResults contains results of the messageStore.StreamMessages
type MessageStoreMockStreamMessagesResults struct {
	b1  storage.Batch
	ch1 chan storage.Message
	err error
}

// Expect sets up expected params for messageStore.StreamMessages
func (mmStreamMessages *mMessageStoreMockStreamMessages) Expect(ctx context.Context, from time.Time, filter storage.Filter, limit uint) *mMessageStoreMockStreamMessages {
	if mmStreamMessages.mock.funcStreamMessages != nil {
		mmStreamMessages.mock.t.Fatalf("MessageStoreMock.StreamMessages mock is already set by Set")
	}

	if mmStreamMessages.defaultExpectation == nil {
		mmStreamMessages.defaultExpectation = &MessageStoreMockStreamMessagesExpectation{}
	}

	mmStreamMessages.defaultExpectation.params = &MessageStoreMockStreamMessagesParams{ctx, from, filter, limit}
	for _, e := range mmStreamMessages.expectations {
		if minimock.Equal(e.params, mmStreamMessages.defaultExpectation.params) {
			mmStreamMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStreamMessages.defaultExpectation.params)
		}
	}

	return mmStreamMessages
}

// Inspect accepts an inspector function that has same arguments as the messageStore.StreamMessages
func (mmStreamMessages *mMessageStoreMockStreamMessages) Inspect(f func(ctx context.Context, from time.Time, filter storage.Filter, limit uint)) *mMessageStoreMockStreamMessages {
	if mmStreamMessages.mock.inspectFuncStreamMessages != nil {
		mmStreamMessages.mock.t.Fatalf("Inspect function is already set for MessageStoreMock.StreamMessages")
	}

	mmStreamMessages.mock.inspectFuncStreamMessages = f

	return mmStreamMessages
}

// Return sets up results that will be returned by messageStore.StreamMessages
func (mmStreamMessages *mMessageStoreMockStreamMessages) Return(b1 storage.Batch, ch1 chan storage.Message, err error) *MessageStoreMock {
	if mmStreamMessages.mock.funcStreamMessages != nil {
		mmStreamMessages.mock.t.Fatalf("MessageStoreMock.StreamMessages mock is already set by Set")
	}

	if mmStreamMessages.defaultExpectation == nil {
		mmStreamMessages.defaultExpectation = &MessageStoreMockStreamMessagesExpectation{mock: mmStreamMessages.mock}
	}
	mmStreamMessages.defaultExpectation.results = &MessageStoreMockStreamMessagesResults{b1, ch1, err}
	return mmStreamMessages.mock
}

// Set uses given function f to mock the messageStore.StreamMessages method
func (mmStreamMessages *mMessageStoreMockStreamMessages) Set(f func(ctx context.Context, from time.Time, filter storage.Filter, limit uint) (b1 storage.Batch, ch1 chan storage.Message, err error)) *MessageStoreMock {
	if mmStreamMessages.defaultExpectation != nil {
		mmStreamMessages.mock.t.Fatalf("Default expectation is already set for the messageStore.StreamMessages method")
	}

	if len(mmStreamMessages.expectations) > 0 {
		mmStreamMessages.mock.t.Fatalf("Some expectations are already set for the messageStore.StreamMessages method")
	}

	mmStreamMessages.mock.funcStreamMessages = f
	return mmStreamMessages.mock
}

// When sets expectation for the messageStore.StreamMessages which will trigger the result defined by the following
// Then helper
func (mmStreamMessages *mMessageStoreMockStreamMessages) When(ctx context.Context, from time.Time, filter storage.Filter, limit uint) *MessageStoreMockStreamMessagesExpectation {
	if mmStreamMessages.mock.funcStreamMessages != nil {
		mmStreamMessages.mock.t.Fatalf("MessageStoreMock.StreamMessages mock is already set by Set")
	}

	expectation := &MessageStoreMockStreamMessagesExpectation{
		mock:   mmStreamMessages.mock,
		params: &MessageStoreMockStreamMessagesParams{ctx, from, filter, limit},
	}
	mmStreamMessages.expectations = append(mmStreamMessages.expectations, expectation)
	return expectation
}

// Then sets up messageStore.StreamMessages return parameters for the expectation previously defined by the When method
func (e *MessageStoreMockStreamMessagesExpectation) Then(b1 storage.Batch, ch1 chan storage.Message, err error) *MessageStoreMock {
	e.results = &MessageStoreMockStreamMessagesResults{b1, ch1, err}
	return e.mock
}

// StreamMessages implements telemetry.messageStore
func (mmStreamMessages *MessageStoreMock) StreamMessages(ctx context.Context, from time.Time, filter storage.Filter, limit uint) (b1 storage.Batch, ch1 chan storage.Message, err error) {
	mm_atomic.AddUint64(&mmStreamMessages.beforeStreamMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmStreamMessages.afterStreamMessagesCounter, 1)

	if mmStreamMessages.inspectFuncStreamMessages != nil {
		mmStreamMessages.inspectFuncStreamMessages(ctx, from, filter, limit)
	}

	mm_params := &MessageStoreMockStreamMessagesParams{ctx, from, filter, limit}

	// Record call args
	mmStreamMessages.StreamMessagesMock.mutex.Lock()
	mmStreamMessages.StreamMessagesMock.callArgs = append(mmStreamMessages.StreamMessagesMock.callArgs, mm_params)
	mmStreamMessages.StreamMessagesMock.mutex.Unlock()

	for _, e := range mmStreamMessages.StreamMessagesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.ch1, e.results.err
		}
	}

	if mmStreamMessages.StreamMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStreamMessages.StreamMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmStreamMessages.StreamMessagesMock.defaultExpectation.params
		mm_got := MessageStoreMockStreamMessagesParams{ctx, from, filter, limit}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStreamMessages.t.Errorf("MessageStoreMock.StreamMessages got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStreamMessages.StreamMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmStreamMessages.t.Fatal("No results are set for the MessageStoreMock.StreamMessages")
		}
		return (*mm_results).b1, (*mm_results).ch1, (*mm_results).err
	}
	if mmStreamMessages.funcStreamMessages != nil {
		return mmStreamMessages.funcStreamMessages(ctx, from, filter, limit)
	}
	mmStreamMessages.t.Fatalf("Unexpected call to MessageStoreMock.StreamMessages. %v %v %v %v", ctx, from, filter, limit)
	return
}

// StreamMessagesAfterCounter returns a count of finished MessageStoreMock.StreamMessages invocations
func (mmStreamMessages *MessageStoreMock) StreamMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStreamMessages.afterStreamMessagesCounter)
}

// StreamMessagesBeforeCounter returns a count of MessageStoreMock.StreamMessages invocations
func (mmStreamMessages *MessageStoreMock) StreamMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStreamMessages.beforeStreamMessagesCounter)
}

// Calls returns a list of arguments used in each call to MessageStoreMock.StreamMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStreamMessages *mMessageStoreMockStreamMessages) Calls() []*MessageStoreMockStreamMessagesParams {
	mmStreamMessages.mutex.RLock()

	argCopy := make([]*MessageStoreMockStreamMessagesParams, len(mmStreamMessages.callArgs))
	copy(argCopy, mmStreamMessages.callArgs)

	mmStreamMessages.mutex.RUnlock()

	return argCopy
}

// MinimockStreamMessagesDone returns true if the count of the StreamMessages invocations corresponds
// the number of defined expectations
func (m *MessageStoreMock) MinimockStreamMessagesDone() bool {
	for _, e := range m.StreamMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StreamMessagesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStreamMessagesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStreamMessages != nil && mm_atomic.LoadUint64(&m.afterStreamMessagesCounter) < 1 {
		return false
	}
	return true
}

// MinimockStreamMessagesInspect logs each unmet expectation
func (m *MessageStoreMock) MinimockStreamMessagesInspect() {
	for _, e := range m.StreamMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageStoreMock.StreamMessages with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StreamMessagesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStreamMessagesCounter) < 1 {
		if m.StreamMessagesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageStoreMock.StreamMessages")
		} else {
			m.t.Errorf("Expected call to MessageStoreMock.StreamMessages with params: %#v", *m.StreamMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStreamMessages != nil && mm_atomic.LoadUint64(&m.afterStreamMessagesCounter) < 1 {
		m.t.Error("Expected call to MessageStoreMock.StreamMessages")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MessageStoreMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockListMessagesInspect()

		m.MinimockStreamMessagesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MessageStoreMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MessageStoreMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockListMessagesDone() &&
		m.MinimockStreamMessagesDone()
}
