package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i google.golang.org/grpc.ServerStream -o ./server_stream_mock.go -n ServerStreamMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"google.golang.org/grpc/metadata"
)

// ServerStreamMock implements grpc.ServerStream
type ServerStreamMock struct {
	t minimock.Tester

	funcContext          func() (c1 context.Context)
	inspectFuncContext   func()
	afterContextCounter  uint64
	beforeContextCounter uint64
	ContextMock          mServerStreamMockContext

	funcRecvMsg          func(m interface{}) (err error)
	inspectFuncRecvMsg   func(m interface{})
	afterRecvMsgCounter  uint64
	beforeRecvMsgCounter uint64
	RecvMsgMock          mServerStreamMockRecvMsg

	funcSendHeader          func(m1 metadata.MD) (err error)
	inspectFuncSendHeader   func(m1 metadata.MD)
	afterSendHeaderCounter  uint64
	beforeSendHeaderCounter uint64
	SendHeaderMock          mServerStreamMockSendHeader

	funcSendMsg          func(m interface{}) (err error)
	inspectFuncSendMsg   func(m interface{})
	afterSendMsgCounter  uint64
	beforeSendMsgCounter uint64
	SendMsgMock          mServerStreamMockSendMsg

	funcSetHeader          func(m1 metadata.MD) (err error)
	inspectFuncSetHeader   func(m1 metadata.MD)
	afterSetHeaderCounter  uint64
	beforeSetHeaderCounter uint64
	SetHeaderMock          mServerStreamMockSetHeader

	funcSetTrailer          func(m1 metadata.MD)
	inspectFuncSetTrailer   func(m1 metadata.MD)
	afterSetTrailerCounter  uint64
	beforeSetTrailerCounter uint64
	SetTrailerMock          mServerStreamMockSetTrailer
}

// NewServerStreamMock returns a mock for grpc.ServerStream
func NewServerStreamMock(t minimock.Tester) *ServerStreamMock {
	m := &ServerStreamMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ContextMock = mServerStreamMockContext{mock: m}

	m.RecvMsgMock = mServerStreamMockRecvMsg{mock: m}
	m.RecvMsgMock.callArgs = []*ServerStreamMockRecvMsgParams{}

	m.SendHeaderMock = mServerStreamMockSendHeader{mock: m}
	m.SendHeaderMock.callArgs = []*ServerStreamMockSendHeaderParams{}

	m.SendMsgMock = mServerStreamMockSendMsg{mock: m}
	m.SendMsgMock.callArgs = []*ServerStreamMockSendMsgParams{}

	m.SetHeaderMock = mServerStreamMockSetHeader{mock: m}
	m.SetHeaderMock.callArgs = []*ServerStreamMockSetHeaderParams{}

	m.SetTrailerMock = mServerStreamMockSetTrailer{mock: m}
	m.SetTrailerMock.callArgs = []*ServerStreamMockSetTrailerParams{}

	return m
}

type mServerStreamMockContext struct {
	mock               *ServerStreamMock
	defaultExpectation *ServerStreamMockContextExpectation
	expectations       []*ServerStreamMockContextExpectation
}

// ServerStreamMockContextExpectation specifies expectation struct of the ServerStream.Context
type ServerStreamMockContextExpectation struct {
	mock *ServerStreamMock

	results *ServerStreamMockContextResults
	Counter uint64
}

// ServerStreamMockContextResults contains results of the ServerStream.Context
type ServerStreamMockContextResults struct {
	c1 context.Context
}

// Expect sets up expected params for ServerStream.Context
func (mmContext *mServerStreamMockContext) Expect() *mServerStreamMockContext {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("ServerStreamMock.Context mock is already set by Set")
	}

	if mmContext.defaultExpectation == nil {
		mmContext.defaultExpectation = &ServerStreamMockContextExpectation{}
	}

	return mmContext
}

// Inspect accepts an inspector function that has same arguments as the ServerStream.Context
func (mmContext *mServerStreamMockContext) Inspect(f func()) *mServerStreamMockContext {
	if mmContext.mock.inspectFuncContext != nil {
		mmContext.mock.t.Fatalf("Inspect function is already set for ServerStreamMock.Context")
	}

	mmContext.mock.inspectFuncContext = f

	return mmContext
}

// Return sets up results that will be returned by ServerStream.Context
func (mmContext *mServerStreamMockContext) Return(c1 context.Context) *ServerStreamMock {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("ServerStreamMock.Context mock is already set by Set")
	}

	if mmContext.defaultExpectation == nil {
		mmContext.defaultExpectation = &ServerStreamMockContextExpectation{mock: mmContext.mock}
	}
	mmContext.defaultExpectation.results = &ServerStreamMockContextResults{c1}
	return mmContext.mock
}

// Set uses given function f to mock the ServerStream.Context method
func (mmContext *mServerStreamMockContext) Set(f func() (c1 context.Context)) *ServerStreamMock {
	if mmContext.defaultExpectation != nil {
		mmContext.mock.t.Fatalf("Default expectation is already set for the ServerStream.Context method")
	}

	if len(mmContext.expectations) > 0 {
		mmContext.mock.t.Fatalf("Some expectations are already set for the ServerStream.Context method")
	}

	mmContext.mock.funcContext = f
	return mmContext.mock
}

// Context implements grpc.ServerStream
func (mmContext *ServerStreamMock) Context() (c1 context.Context) {
	mm_atomic.AddUint64(&mmContext.beforeContextCounter, 1)
	defer mm_atomic.AddUint64(&mmContext.afterContextCounter, 1)

	if mmContext.inspectFuncContext != nil {
		mmContext.inspectFuncContext()
	}

	if mmContext.ContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContext.ContextMock.defaultExpectation.Counter, 1)

		mm_results := mmContext.ContextMock.defaultExpectation.results
		if mm_results == nil {
			mmContext.t.Fatal("No results are set for the ServerStreamMock.Context")
		}
		return (*mm_results).c1
	}
	if mmContext.funcContext != nil {
		return mmContext.funcContext()
	}
	mmContext.t.Fatalf("Unexpected call to ServerStreamMock.Context.")
	return
}

// ContextAfterCounter returns a count of finished ServerStreamMock.Context invocations
func (mmContext *ServerStreamMock) ContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContext.afterContextCounter)
}

// ContextBeforeCounter returns a count of ServerStreamMock.Context invocations
func (mmContext *ServerStreamMock) ContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContext.beforeContextCounter)
}

// MinimockContextDone returns true if the count of the Context invocations corresponds
// the number of defined expectations
func (m *ServerStreamMock) MinimockContextDone() bool {
	for _, e := range m.ContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContext != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockContextInspect logs each unmet expectation
func (m *ServerStreamMock) MinimockContextInspect() {
	for _, e := range m.ContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServerStreamMock.Context")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		m.t.Error("Expected call to ServerStreamMock.Context")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContext != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		m.t.Error("Expected call to ServerStreamMock.Context")
	}
}

type mServerStreamMockRecvMsg struct {
	mock               *ServerStreamMock
	defaultExpectation *ServerStreamMockRecvMsgExpectation
	expectations       []*ServerStreamMockRecvMsgExpectation

	callArgs []*ServerStreamMockRecvMsgParams
	mutex    sync.RWMutex
}

// ServerStreamMockRecvMsgExpectation specifies expectation struct of the ServerStream.RecvMsg
type ServerStreamMockRecvMsgExpectation struct {
	mock    *ServerStreamMock
	params  *ServerStreamMockRecvMsgParams
	results *ServerStreamMockRecvMsgResults
	Counter uint64
}

// ServerStreamMockRecvMsgParams contains parameters of the ServerStream.RecvMsg
type ServerStreamMockRecvMsgParams struct {
	m interface{}
}

// ServerStreamMockRecvMsgResults contains results of the ServerStream.RecvMsg
type ServerStreamMockRecvMsgResults struct {
	err error
}

// Expect sets up expected params for ServerStream.RecvMsg
func (mmRecvMsg *mServerStreamMockRecvMsg) Expect(m interface{}) *mServerStreamMockRecvMsg {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ServerStreamMock.RecvMsg mock is already set by Set")
	}

	if mmRecvMsg.defaultExpectation == nil {
		mmRecvMsg.defaultExpectation = &ServerStreamMockRecvMsgExpectation{}
	}

	mmRecvMsg.defaultExpectation.params = &ServerStreamMockRecvMsgParams{m}
	for _, e := range mmRecvMsg.expectations {
		if minimock.Equal(e.params, mmRecvMsg.defaultExpectation.params) {
			mmRecvMsg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRecvMsg.defaultExpectation.params)
		}
	}

	return mmRecvMsg
}

// Inspect accepts an inspector function that has same arguments as the ServerStream.RecvMsg
func (mmRecvMsg *mServerStreamMockRecvMsg) Inspect(f func(m interface{})) *mServerStreamMockRecvMsg {
	if mmRecvMsg.mock.inspectFuncRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("Inspect function is already set for ServerStreamMock.RecvMsg")
	}

	mmRecvMsg.mock.inspectFuncRecvMsg = f

	return mmRecvMsg
}

// Return sets up results that will be returned by ServerStream.RecvMsg
func (mmRecvMsg *mServerStreamMockRecvMsg) Return(err error) *ServerStreamMock {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ServerStreamMock.RecvMsg mock is already set by Set")
	}

	if mmRecvMsg.defaultExpectation == nil {
		mmRecvMsg.defaultExpectation = &ServerStreamMockRecvMsgExpectation{mock: mmRecvMsg.mock}
	}
	mmRecvMsg.defaultExpectation.results = &ServerStreamMockRecvMsgResults{err}
	return mmRecvMsg.mock
}

// Set uses given function f to mock the ServerStream.RecvMsg method
func (mmRecvMsg *mServerStreamMockRecvMsg) Set(f func(m interface{}) (err error)) *ServerStreamMock {
	if mmRecvMsg.defaultExpectation != nil {
		mmRecvMsg.mock.t.Fatalf("Default expectation is already set for the ServerStream.RecvMsg method")
	}

	if len(mmRecvMsg.expectations) > 0 {
		mmRecvMsg.mock.t.Fatalf("Some expectations are already set for the ServerStream.RecvMsg method")
	}

	mmRecvMsg.mock.funcRecvMsg = f
	return mmRecvMsg.mock
}

// When sets expectation for the ServerStream.RecvMsg which will trigger the result defined by the following
// Then helper
func (mmRecvMsg *mServerStreamMockRecvMsg) When(m interface{}) *ServerStreamMockRecvMsgExpectation {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ServerStreamMock.RecvMsg mock is already set by Set")
	}

	expectation := &ServerStreamMockRecvMsgExpectation{
		mock:   mmRecvMsg.mock,
		params: &ServerStreamMockRecvMsgParams{m},
	}
	mmRecvMsg.expectations = append(mmRecvMsg.expectations, expectation)
	return expectation
}

// Then sets up ServerStream.RecvMsg return parameters for the expectation previously defined by the When method
func (e *ServerStreamMockRecvMsgExpectation) Then(err error) *ServerStreamMock {
	e.results = &ServerStreamMockRecvMsgResults{err}
	return e.mock
}

// RecvMsg implements grpc.ServerStream
func (mmRecvMsg *ServerStreamMock) RecvMsg(m interface{}) (err error) {
	mm_atomic.AddUint64(&mmRecvMsg.beforeRecvMsgCounter, 1)
	defer mm_atomic.AddUint64(&mmRecvMsg.afterRecvMsgCounter, 1)

	if mmRecvMsg.inspectFuncRecvMsg != nil {
		mmRecvMsg.inspectFuncRecvMsg(m)
	}

	mm_params := &ServerStreamMockRecvMsgParams{m}

	// Record call args
	mmRecvMsg.RecvMsgMock.mutex.Lock()
	mmRecvMsg.RecvMsgMock.callArgs = append(mmRecvMsg.RecvMsgMock.callArgs, mm_params)
	mmRecvMsg.RecvMsgMock.mutex.Unlock()

	for _, e := range mmRecvMsg.RecvMsgMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRecvMsg.RecvMsgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecvMsg.RecvMsgMock.defaultExpectation.Counter, 1)
		mm_want := mmRecvMsg.RecvMsgMock.defaultExpectation.params
		mm_got := ServerStreamMockRecvMsgParams{m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRecvMsg.t.Errorf("ServerStreamMock.RecvMsg got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRecvMsg.RecvMsgMock.defaultExpectation.results
		if mm_results == nil {
			mmRecvMsg.t.Fatal("No results are set for the ServerStreamMock.RecvMsg")
		}
		return (*mm_results).err
	}
	if mmRecvMsg.funcRecvMsg != nil {
		return mmRecvMsg.funcRecvMsg(m)
	}
	mmRecvMsg.t.Fatalf("Unexpected call to ServerStreamMock.RecvMsg. %v", m)
	return
}

// RecvMsgAfterCounter returns a count of finished ServerStreamMock.RecvMsg invocations
func (mmRecvMsg *ServerStreamMock) RecvMsgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecvMsg.afterRecvMsgCounter)
}

// RecvMsgBeforeCounter returns a count of ServerStreamMock.RecvMsg invocations
func (mmRecvMsg *ServerStreamMock) RecvMsgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecvMsg.beforeRecvMsgCounter)
}

// Calls returns a list of arguments used in each call to ServerStreamMock.RecvMsg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRecvMsg *mServerStreamMockRecvMsg) Calls() []*ServerStreamMockRecvMsgParams {
	mmRecvMsg.mutex.RLock()

	argCopy := make([]*ServerStreamMockRecvMsgParams, len(mmRecvMsg.callArgs))
	copy(argCopy, mmRecvMsg.callArgs)

	mmRecvMsg.mutex.RUnlock()

	return argCopy
}

// MinimockRecvMsgDone returns true if the count of the RecvMsg invocations corresponds
// the number of defined expectations
func (m *ServerStreamMock) MinimockRecvMsgDone() bool {
	for _, e := range m.RecvMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecvMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecvMsg != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		return false
	}
	return true
}

// MinimockRecvMsgInspect logs each unmet expectation
func (m *ServerStreamMock) MinimockRecvMsgInspect() {
	for _, e := range m.RecvMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServerStreamMock.RecvMsg with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecvMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		if m.RecvMsgMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServerStreamMock.RecvMsg")
		} else {
			m.t.Errorf("Expected call to ServerStreamMock.RecvMsg with params: %#v", *m.RecvMsgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecvMsg != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		m.t.Error("Expected call to ServerStreamMock.RecvMsg")
	}
}

type mServerStreamMockSendHeader struct {
	mock               *ServerStreamMock
	defaultExpectation *ServerStreamMockSendHeaderExpectation
	expectations       []*ServerStreamMockSendHeaderExpectation

	callArgs []*ServerStreamMockSendHeaderParams
	mutex    sync.RWMutex
}

// ServerStreamMockSendHeaderExpectation specifies expectation struct of the ServerStream.SendHeader
type ServerStreamMockSendHeaderExpectation struct {
	mock    *ServerStreamMock
	params  *ServerStreamMockSendHeaderParams
	results *ServerStreamMockSendHeaderResults
	Counter uint64
}

// ServerStreamMockSendHeaderParams contains parameters of the ServerStream.SendHeader
type ServerStreamMockSendHeaderParams struct {
	m1 metadata.MD
}

// ServerStreamMockSendHeaderResults contains results of the ServerStream.SendHeader
type ServerStreamMockSendHeaderResults struct {
	err error
}

// Expect sets up expected params for ServerStream.SendHeader
func (mmSendHeader *mServerStreamMockSendHeader) Expect(m1 metadata.MD) *mServerStreamMockSendHeader {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("ServerStreamMock.SendHeader mock is already set by Set")
	}

	if mmSendHeader.defaultExpectation == nil {
		mmSendHeader.defaultExpectation = &ServerStreamMockSendHeaderExpectation{}
	}

	mmSendHeader.defaultExpectation.params = &ServerStreamMockSendHeaderParams{m1}
	for _, e := range mmSendHeader.expectations {
		if minimock.Equal(e.params, mmSendHeader.defaultExpectation.params) {
			mmSendHeader.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendHeader.defaultExpectation.params)
		}
	}

	return mmSendHeader
}

// Inspect accepts an inspector function that has same arguments as the ServerStream.SendHeader
func (mmSendHeader *mServerStreamMockSendHeader) Inspect(f func(m1 metadata.MD)) *mServerStreamMockSendHeader {
	if mmSendHeader.mock.inspectFuncSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("Inspect function is already set for ServerStreamMock.SendHeader")
	}

	mmSendHeader.mock.inspectFuncSendHeader = f

	return mmSendHeader
}

// Return sets up results that will be returned by ServerStream.SendHeader
func (mmSendHeader *mServerStreamMockSendHeader) Return(err error) *ServerStreamMock {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("ServerStreamMock.SendHeader mock is already set by Set")
	}

	if mmSendHeader.defaultExpectation == nil {
		mmSendHeader.defaultExpectation = &ServerStreamMockSendHeaderExpectation{mock: mmSendHeader.mock}
	}
	mmSendHeader.defaultExpectation.results = &ServerStreamMockSendHeaderResults{err}
	return mmSendHeader.mock
}

// Set uses given function f to mock the ServerStream.SendHeader method
func (mmSendHeader *mServerStreamMockSendHeader) Set(f func(m1 metadata.MD) (err error)) *ServerStreamMock {
	if mmSendHeader.defaultExpectation != nil {
		mmSendHeader.mock.t.Fatalf("Default expectation is already set for the ServerStream.SendHeader method")
	}

	if len(mmSendHeader.expectations) > 0 {
		mmSendHeader.mock.t.Fatalf("Some expectations are already set for the ServerStream.SendHeader method")
	}

	mmSendHeader.mock.funcSendHeader = f
	return mmSendHeader.mock
}

// When sets expectation for the ServerStream.SendHeader which will trigger the result defined by the following
// Then helper
func (mmSendHeader *mServerStreamMockSendHeader) When(m1 metadata.MD) *ServerStreamMockSendHeaderExpectation {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("ServerStreamMock.SendHeader mock is already set by Set")
	}

	expectation := &ServerStreamMockSendHeaderExpectation{
		mock:   mmSendHeader.mock,
		params: &ServerStreamMockSendHeaderParams{m1},
	}
	mmSendHeader.expectations = append(mmSendHeader.expectations, expectation)
	return expectation
}

// Then sets up ServerStream.SendHeader return parameters for the expectation previously defined by the When method
func (e *ServerStreamMockSendHeaderExpectation) Then(err error) *ServerStreamMock {
	e.results = &ServerStreamMockSendHeaderResults{err}
	return e.mock
}

// SendHeader implements grpc.ServerStream
func (mmSendHeader *ServerStreamMock) SendHeader(m1 metadata.MD) (err error) {
	mm_atomic.AddUint64(&mmSendHeader.beforeSendHeaderCounter, 1)
	defer mm_atomic.AddUint64(&mmSendHeader.afterSendHeaderCounter, 1)

	if mmSendHeader.inspectFuncSendHeader != nil {
		mmSendHeader.inspectFuncSendHeader(m1)
	}

	mm_params := &ServerStreamMockSendHeaderParams{m1}

	// Record call args
	mmSendHeader.SendHeaderMock.mutex.Lock()
	mmSendHeader.SendHeaderMock.callArgs = append(mmSendHeader.SendHeaderMock.callArgs, mm_params)
	mmSendHeader.SendHeaderMock.mutex.Unlock()

	for _, e := range mmSendHeader.SendHeaderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendHeader.SendHeaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendHeader.SendHeaderMock.defaultExpectation.Counter, 1)
		mm_want := mmSendHeader.SendHeaderMock.defaultExpectation.params
		mm_got := ServerStreamMockSendHeaderParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendHeader.t.Errorf("ServerStreamMock.SendHeader got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendHeader.SendHeaderMock.defaultExpectation.results
		if mm_results == nil {
			mmSendHeader.t.Fatal("No results are set for the ServerStreamMock.SendHeader")
		}
		return (*mm_results).err
	}
	if mmSendHeader.funcSendHeader != nil {
		return mmSendHeader.funcSendHeader(m1)
	}
	mmSendHeader.t.Fatalf("Unexpected call to ServerStreamMock.SendHeader. %v", m1)
	return
}

// SendHeaderAfterCounter returns a count of finished ServerStreamMock.SendHeader invocations
func (mmSendHeader *ServerStreamMock) SendHeaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendHeader.afterSendHeaderCounter)
}

// SendHeaderBeforeCounter returns a count of ServerStreamMock.SendHeader invocations
func (mmSendHeader *ServerStreamMock) SendHeaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendHeader.beforeSendHeaderCounter)
}

// Calls returns a list of arguments used in each call to ServerStreamMock.SendHeader.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendHeader *mServerStreamMockSendHeader) Calls() []*ServerStreamMockSendHeaderParams {
	mmSendHeader.mutex.RLock()

	argCopy := make([]*ServerStreamMockSendHeaderParams, len(mmSendHeader.callArgs))
	copy(argCopy, mmSendHeader.callArgs)

	mmSendHeader.mutex.RUnlock()

	return argCopy
}

// MinimockSendHeaderDone returns true if the count of the SendHeader invocations corresponds
// the number of defined expectations
func (m *ServerStreamMock) MinimockSendHeaderDone() bool {
	for _, e := range m.SendHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendHeaderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendHeader != nil && mm_atomic.LoadUint64(&m.afterSendHeaderCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendHeaderInspect logs each unmet expectation
func (m *ServerStreamMock) MinimockSendHeaderInspect() {
	for _, e := range m.SendHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServerStreamMock.SendHeader with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendHeaderCounter) < 1 {
		if m.SendHeaderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServerStreamMock.SendHeader")
		} else {
			m.t.Errorf("Expected call to ServerStreamMock.SendHeader with params: %#v", *m.SendHeaderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendHeader != nil && mm_atomic.LoadUint64(&m.afterSendHeaderCounter) < 1 {
		m.t.Error("Expected call to ServerStreamMock.SendHeader")
	}
}

type mServerStreamMockSendMsg struct {
	mock               *ServerStreamMock
	defaultExpectation *ServerStreamMockSendMsgExpectation
	expectations       []*ServerStreamMockSendMsgExpectation

	callArgs []*ServerStreamMockSendMsgParams
	mutex    sync.RWMutex
}

// ServerStreamMockSendMsgExpectation specifies expectation struct of the ServerStream.SendMsg
type ServerStreamMockSendMsgExpectation struct {
	mock    *ServerStreamMock
	params  *ServerStreamMockSendMsgParams
	results *ServerStreamMockSendMsgResults
	Counter uint64
}

// ServerStreamMockSendMsgParams contains parameters of the ServerStream.SendMsg
type ServerStreamMockSendMsgParams struct {
	m interface{}
}

// ServerStreamMockSendMsgResults contains results of the ServerStream.SendMsg
type ServerStreamMockSendMsgResults struct {
	err error
}

// Expect sets up expected params for ServerStream.SendMsg
func (mmSendMsg *mServerStreamMockSendMsg) Expect(m interface{}) *mServerStreamMockSendMsg {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ServerStreamMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &ServerStreamMockSendMsgExpectation{}
	}

	mmSendMsg.defaultExpectation.params = &ServerStreamMockSendMsgParams{m}
	for _, e := range mmSendMsg.expectations {
		if minimock.Equal(e.params, mmSendMsg.defaultExpectation.params) {
			mmSendMsg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMsg.defaultExpectation.params)
		}
	}

	return mmSendMsg
}

// Inspect accepts an inspector function that has same arguments as the ServerStream.SendMsg
func (mmSendMsg *mServerStreamMockSendMsg) Inspect(f func(m interface{})) *mServerStreamMockSendMsg {
	if mmSendMsg.mock.inspectFuncSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("Inspect function is already set for ServerStreamMock.SendMsg")
	}

	mmSendMsg.mock.inspectFuncSendMsg = f

	return mmSendMsg
}

// Return sets up results that will be returned by ServerStream.SendMsg
func (mmSendMsg *mServerStreamMockSendMsg) Return(err error) *ServerStreamMock {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ServerStreamMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &ServerStreamMockSendMsgExpectation{mock: mmSendMsg.mock}
	}
	mmSendMsg.defaultExpectation.results = &ServerStreamMockSendMsgResults{err}
	return mmSendMsg.mock
}

// Set uses given function f to mock the ServerStream.SendMsg method
func (mmSendMsg *mServerStreamMockSendMsg) Set(f func(m interface{}) (err error)) *ServerStreamMock {
	if mmSendMsg.defaultExpectation != nil {
		mmSendMsg.mock.t.Fatalf("Default expectation is already set for the ServerStream.SendMsg method")
	}

	if len(mmSendMsg.expectations) > 0 {
		mmSendMsg.mock.t.Fatalf("Some expectations are already set for the ServerStream.SendMsg method")
	}

	mmSendMsg.mock.funcSendMsg = f
	return mmSendMsg.mock
}

// When sets expectation for the ServerStream.SendMsg which will trigger the result defined by the following
// Then helper
func (mmSendMsg *mServerStreamMockSendMsg) When(m interface{}) *ServerStreamMockSendMsgExpectation {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ServerStreamMock.SendMsg mock is already set by Set")
	}

	expectation := &ServerStreamMockSendMsgExpectation{
		mock:   mmSendMsg.mock,
		params: &ServerStreamMockSendMsgParams{m},
	}
	mmSendMsg.expectations = append(mmSendMsg.expectations, expectation)
	return expectation
}

// Then sets up ServerStream.SendMsg return parameters for the expectation previously defined by the When method
func (e *ServerStreamMockSendMsgExpectation) Then(err error) *ServerStreamMock {
	e.results = &ServerStreamMockSendMsgResults{err}
	return e.mock
}

// SendMsg implements grpc.ServerStream
func (mmSendMsg *ServerStreamMock) SendMsg(m interface{}) (err error) {
	mm_atomic.AddUint64(&mmSendMsg.beforeSendMsgCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMsg.afterSendMsgCounter, 1)

	if mmSendMsg.inspectFuncSendMsg != nil {
		mmSendMsg.inspectFuncSendMsg(m)
	}

	mm_params := &ServerStreamMockSendMsgParams{m}

	// Record call args
	mmSendMsg.SendMsgMock.mutex.Lock()
	mmSendMsg.SendMsgMock.callArgs = append(mmSendMsg.SendMsgMock.callArgs, mm_params)
	mmSendMsg.SendMsgMock.mutex.Unlock()

	for _, e := range mmSendMsg.SendMsgMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMsg.SendMsgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMsg.SendMsgMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMsg.SendMsgMock.defaultExpectation.params
		mm_got := ServerStreamMockSendMsgParams{m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMsg.t.Errorf("ServerStreamMock.SendMsg got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMsg.SendMsgMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMsg.t.Fatal("No results are set for the ServerStreamMock.SendMsg")
		}
		return (*mm_results).err
	}
	if mmSendMsg.funcSendMsg != nil {
		return mmSendMsg.funcSendMsg(m)
	}
	mmSendMsg.t.Fatalf("Unexpected call to ServerStreamMock.SendMsg. %v", m)
	return
}

// SendMsgAfterCounter returns a count of finished ServerStreamMock.SendMsg invocations
func (mmSendMsg *ServerStreamMock) SendMsgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMsg.afterSendMsgCounter)
}

// SendMsgBeforeCounter returns a count of ServerStreamMock.SendMsg invocations
func (mmSendMsg *ServerStreamMock) SendMsgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMsg.beforeSendMsgCounter)
}

// Calls returns a list of arguments used in each call to ServerStreamMock.SendMsg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMsg *mServerStreamMockSendMsg) Calls() []*ServerStreamMockSendMsgParams {
	mmSendMsg.mutex.RLock()

	argCopy := make([]*ServerStreamMockSendMsgParams, len(mmSendMsg.callArgs))
	copy(argCopy, mmSendMsg.callArgs)

	mmSendMsg.mutex.RUnlock()

	return argCopy
}

// MinimockSendMsgDone returns true if the count of the SendMsg invocations corresponds
// the number of defined expectations
func (m *ServerStreamMock) MinimockSendMsgDone() bool {
	for _, e := range m.SendMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMsg != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMsgInspect logs each unmet expectation
func (m *ServerStreamMock) MinimockSendMsgInspect() {
	for _, e := range m.SendMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServerStreamMock.SendMsg with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		if m.SendMsgMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServerStreamMock.SendMsg")
		} else {
			m.t.Errorf("Expected call to ServerStreamMock.SendMsg with params: %#v", *m.SendMsgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMsg != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		m.t.Error("Expected call to ServerStreamMock.SendMsg")
	}
}

type mServerStreamMockSetHeader struct {
	mock               *ServerStreamMock
	defaultExpectation *ServerStreamMockSetHeaderExpectation
	expectations       []*ServerStreamMockSetHeaderExpectation

	callArgs []*ServerStreamMockSetHeaderParams
	mutex    sync.RWMutex
}

// ServerStreamMockSetHeaderExpectation specifies expectation struct of the ServerStream.SetHeader
type ServerStreamMockSetHeaderExpectation struct {
	mock    *ServerStreamMock
	params  *ServerStreamMockSetHeaderParams
	results *ServerStreamMockSetHeaderResults
	Counter uint64
}

// ServerStreamMockSetHeaderParams contains parameters of the ServerStream.SetHeader
type ServerStreamMockSetHeaderParams struct {
	m1 metadata.MD
}

// ServerStreamMockSetHeaderResults contains results of the ServerStream.SetHeader
type ServerStreamMockSetHeaderResults struct {
	err error
}

// Expect sets up expected params for ServerStream.SetHeader
func (mmSetHeader *mServerStreamMockSetHeader) Expect(m1 metadata.MD) *mServerStreamMockSetHeader {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("ServerStreamMock.SetHeader mock is already set by Set")
	}

	if mmSetHeader.defaultExpectation == nil {
		mmSetHeader.defaultExpectation = &ServerStreamMockSetHeaderExpectation{}
	}

	mmSetHeader.defaultExpectation.params = &ServerStreamMockSetHeaderParams{m1}
	for _, e := range mmSetHeader.expectations {
		if minimock.Equal(e.params, mmSetHeader.defaultExpectation.params) {
			mmSetHeader.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetHeader.defaultExpectation.params)
		}
	}

	return mmSetHeader
}

// Inspect accepts an inspector function that has same arguments as the ServerStream.SetHeader
func (mmSetHeader *mServerStreamMockSetHeader) Inspect(f func(m1 metadata.MD)) *mServerStreamMockSetHeader {
	if mmSetHeader.mock.inspectFuncSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("Inspect function is already set for ServerStreamMock.SetHeader")
	}

	mmSetHeader.mock.inspectFuncSetHeader = f

	return mmSetHeader
}

// Return sets up results that will be returned by ServerStream.SetHeader
func (mmSetHeader *mServerStreamMockSetHeader) Return(err error) *ServerStreamMock {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("ServerStreamMock.SetHeader mock is already set by Set")
	}

	if mmSetHeader.defaultExpectation == nil {
		mmSetHeader.defaultExpectation = &ServerStreamMockSetHeaderExpectation{mock: mmSetHeader.mock}
	}
	mmSetHeader.defaultExpectation.results = &ServerStreamMockSetHeaderResults{err}
	return mmSetHeader.mock
}

// Set uses given function f to mock the ServerStream.SetHeader method
func (mmSetHeader *mServerStreamMockSetHeader) Set(f func(m1 metadata.MD) (err error)) *ServerStreamMock {
	if mmSetHeader.defaultExpectation != nil {
		mmSetHeader.mock.t.Fatalf("Default expectation is already set for the ServerStream.SetHeader method")
	}

	if len(mmSetHeader.expectations) > 0 {
		mmSetHeader.mock.t.Fatalf("Some expectations are already set for the ServerStream.SetHeader method")
	}

	mmSetHeader.mock.funcSetHeader = f
	return mmSetHeader.mock
}

// When sets expectation for the ServerStream.SetHeader which will trigger the result defined by the following
// Then helper
func (mmSetHeader *mServerStreamMockSetHeader) When(m1 metadata.MD) *ServerStreamMockSetHeaderExpectation {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("ServerStreamMock.SetHeader mock is already set by Set")
	}

	expectation := &ServerStreamMockSetHeaderExpectation{
		mock:   mmSetHeader.mock,
		params: &ServerStreamMockSetHeaderParams{m1},
	}
	mmSetHeader.expectations = append(mmSetHeader.expectations, expectation)
	return expectation
}

// Then sets up ServerStream.SetHeader return parameters for the expectation previously defined by the When method
func (e *ServerStreamMockSetHeaderExpectation) Then(err error) *ServerStreamMock {
	e.results = &ServerStreamMockSetHeaderResults{err}
	return e.mock
}

// SetHeader implements grpc.ServerStream
func (mmSetHeader *ServerStreamMock) SetHeader(m1 metadata.MD) (err error) {
	mm_atomic.AddUint64(&mmSetHeader.beforeSetHeaderCounter, 1)
	defer mm_atomic.AddUint64(&mmSetHeader.afterSetHeaderCounter, 1)

	if mmSetHeader.inspectFuncSetHeader != nil {
		mmSetHeader.inspectFuncSetHeader(m1)
	}

	mm_params := &ServerStreamMockSetHeaderParams{m1}

	// Record call args
	mmSetHeader.SetHeaderMock.mutex.Lock()
	mmSetHeader.SetHeaderMock.callArgs = append(mmSetHeader.SetHeaderMock.callArgs, mm_params)
	mmSetHeader.SetHeaderMock.mutex.Unlock()

	for _, e := range mmSetHeader.SetHeaderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetHeader.SetHeaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetHeader.SetHeaderMock.defaultExpectation.Counter, 1)
		mm_want := mmSetHeader.SetHeaderMock.defaultExpectation.params
		mm_got := ServerStreamMockSetHeaderParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetHeader.t.Errorf("ServerStreamMock.SetHeader got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetHeader.SetHeaderMock.defaultExpectation.results
		if mm_results == nil {
			mmSetHeader.t.Fatal("No results are set for the ServerStreamMock.SetHeader")
		}
		return (*mm_results).err
	}
	if mmSetHeader.funcSetHeader != nil {
		return mmSetHeader.funcSetHeader(m1)
	}
	mmSetHeader.t.Fatalf("Unexpected call to ServerStreamMock.SetHeader. %v", m1)
	return
}

// SetHeaderAfterCounter returns a count of finished ServerStreamMock.SetHeader invocations
func (mmSetHeader *ServerStreamMock) SetHeaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetHeader.afterSetHeaderCounter)
}

// SetHeaderBeforeCounter returns a count of ServerStreamMock.SetHeader invocations
func (mmSetHeader *ServerStreamMock) SetHeaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetHeader.beforeSetHeaderCounter)
}

// Calls returns a list of arguments used in each call to ServerStreamMock.SetHeader.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetHeader *mServerStreamMockSetHeader) Calls() []*ServerStreamMockSetHeaderParams {
	mmSetHeader.mutex.RLock()

	argCopy := make([]*ServerStreamMockSetHeaderParams, len(mmSetHeader.callArgs))
	copy(argCopy, mmSetHeader.callArgs)

	mmSetHeader.mutex.RUnlock()

	return argCopy
}

// MinimockSetHeaderDone returns true if the count of the SetHeader invocations corresponds
// the number of defined expectations
func (m *ServerStreamMock) MinimockSetHeaderDone() bool {
	for _, e := range m.SetHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetHeaderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetHeader != nil && mm_atomic.LoadUint64(&m.afterSetHeaderCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetHeaderInspect logs each unmet expectation
func (m *ServerStreamMock) MinimockSetHeaderInspect() {
	for _, e := range m.SetHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServerStreamMock.SetHeader with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetHeaderCounter) < 1 {
		if m.SetHeaderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServerStreamMock.SetHeader")
		} else {
			m.t.Errorf("Expected call to ServerStreamMock.SetHeader with params: %#v", *m.SetHeaderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetHeader != nil && mm_atomic.LoadUint64(&m.afterSetHeaderCounter) < 1 {
		m.t.Error("Expected call to ServerStreamMock.SetHeader")
	}
}

type mServerStreamMockSetTrailer struct {
	mock               *ServerStreamMock
	defaultExpectation *ServerStreamMockSetTrailerExpectation
	expectations       []*ServerStreamMockSetTrailerExpectation

	callArgs []*ServerStreamMockSetTrailerParams
	mutex    sync.RWMutex
}

// ServerStreamMockSetTrailerExpectation specifies expectation struct of the ServerStream.SetTrailer
type ServerStreamMockSetTrailerExpectation struct {
	mock   *ServerStreamMock
	params *ServerStreamMockSetTrailerParams

	Counter uint64
}

// ServerStreamMockSetTrailerParams contains parameters of the ServerStream.SetTrailer
type ServerStreamMockSetTrailerParams struct {
	m1 metadata.MD
}

// Expect sets up expected params for ServerStream.SetTrailer
func (mmSetTrailer *mServerStreamMockSetTrailer) Expect(m1 metadata.MD) *mServerStreamMockSetTrailer {
	if mmSetTrailer.mock.funcSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("ServerStreamMock.SetTrailer mock is already set by Set")
	}

	if mmSetTrailer.defaultExpectation == nil {
		mmSetTrailer.defaultExpectation = &ServerStreamMockSetTrailerExpectation{}
	}

	mmSetTrailer.defaultExpectation.params = &ServerStreamMockSetTrailerParams{m1}
	for _, e := range mmSetTrailer.expectations {
		if minimock.Equal(e.params, mmSetTrailer.defaultExpectation.params) {
			mmSetTrailer.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetTrailer.defaultExpectation.params)
		}
	}

	return mmSetTrailer
}

// Inspect accepts an inspector function that has same arguments as the ServerStream.SetTrailer
func (mmSetTrailer *mServerStreamMockSetTrailer) Inspect(f func(m1 metadata.MD)) *mServerStreamMockSetTrailer {
	if mmSetTrailer.mock.inspectFuncSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("Inspect function is already set for ServerStreamMock.SetTrailer")
	}

	mmSetTrailer.mock.inspectFuncSetTrailer = f

	return mmSetTrailer
}

// Return sets up results that will be returned by ServerStream.SetTrailer
func (mmSetTrailer *mServerStreamMockSetTrailer) Return() *ServerStreamMock {
	if mmSetTrailer.mock.funcSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("ServerStreamMock.SetTrailer mock is already set by Set")
	}

	if mmSetTrailer.defaultExpectation == nil {
		mmSetTrailer.defaultExpectation = &ServerStreamMockSetTrailerExpectation{mock: mmSetTrailer.mock}
	}

	return mmSetTrailer.mock
}

// Set uses given function f to mock the ServerStream.SetTrailer method
func (mmSetTrailer *mServerStreamMockSetTrailer) Set(f func(m1 metadata.MD)) *ServerStreamMock {
	if mmSetTrailer.defaultExpectation != nil {
		mmSetTrailer.mock.t.Fatalf("Default expectation is already set for the ServerStream.SetTrailer method")
	}

	if len(mmSetTrailer.expectations) > 0 {
		mmSetTrailer.mock.t.Fatalf("Some expectations are already set for the ServerStream.SetTrailer method")
	}

	mmSetTrailer.mock.funcSetTrailer = f
	return mmSetTrailer.mock
}

// SetTrailer implements grpc.ServerStream
func (mmSetTrailer *ServerStreamMock) SetTrailer(m1 metadata.MD) {
	mm_atomic.AddUint64(&mmSetTrailer.beforeSetTrailerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetTrailer.afterSetTrailerCounter, 1)

	if mmSetTrailer.inspectFuncSetTrailer != nil {
		mmSetTrailer.inspectFuncSetTrailer(m1)
	}

	mm_params := &ServerStreamMockSetTrailerParams{m1}

	// Record call args
	mmSetTrailer.SetTrailerMock.mutex.Lock()
	mmSetTrailer.SetTrailerMock.callArgs = append(mmSetTrailer.SetTrailerMock.callArgs, mm_params)
	mmSetTrailer.SetTrailerMock.mutex.Unlock()

	for _, e := range mmSetTrailer.SetTrailerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetTrailer.SetTrailerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetTrailer.SetTrailerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetTrailer.SetTrailerMock.defaultExpectation.params
		mm_got := ServerStreamMockSetTrailerParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetTrailer.t.Errorf("ServerStreamMock.SetTrailer got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetTrailer.funcSetTrailer != nil {
		mmSetTrailer.funcSetTrailer(m1)
		return
	}
	mmSetTrailer.t.Fatalf("Unexpected call to ServerStreamMock.SetTrailer. %v", m1)

}

// SetTrailerAfterCounter returns a count of finished ServerStreamMock.SetTrailer invocations
func (mmSetTrailer *ServerStreamMock) SetTrailerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTrailer.afterSetTrailerCounter)
}

// SetTrailerBeforeCounter returns a count of ServerStreamMock.SetTrailer invocations
func (mmSetTrailer *ServerStreamMock) SetTrailerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTrailer.beforeSetTrailerCounter)
}

// Calls returns a list of arguments used in each call to ServerStreamMock.SetTrailer.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetTrailer *mServerStreamMockSetTrailer) Calls() []*ServerStreamMockSetTrailerParams {
	mmSetTrailer.mutex.RLock()

	argCopy := make([]*ServerStreamMockSetTrailerParams, len(mmSetTrailer.callArgs))
	copy(argCopy, mmSetTrailer.callArgs)

	mmSetTrailer.mutex.RUnlock()

	return argCopy
}

// MinimockSetTrailerDone returns true if the count of the SetTrailer invocations corresponds
// the number of defined expectations
func (m *ServerStreamMock) MinimockSetTrailerDone() bool {
	for _, e := range m.SetTrailerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTrailerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTrailerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTrailer != nil && mm_atomic.LoadUint64(&m.afterSetTrailerCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetTrailerInspect logs each unmet expectation
func (m *ServerStreamMock) MinimockSetTrailerInspect() {
	for _, e := range m.SetTrailerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServerStreamMock.SetTrailer with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTrailerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTrailerCounter) < 1 {
		if m.SetTrailerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServerStreamMock.SetTrailer")
		} else {
			m.t.Errorf("Expected call to ServerStreamMock.SetTrailer with params: %#v", *m.SetTrailerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTrailer != nil && mm_atomic.LoadUint64(&m.afterSetTrailerCounter) < 1 {
		m.t.Error("Expected call to ServerStreamMock.SetTrailer")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServerStreamMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockContextInspect()

		m.MinimockRecvMsgInspect()

		m.MinimockSendHeaderInspect()

		m.MinimockSendMsgInspect()

		m.MinimockSetHeaderInspect()

		m.MinimockSetTrailerInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServerStreamMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServerStreamMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockContextDone() &&
		m.MinimockRecvMsgDone() &&
		m.MinimockSendHeaderDone() &&
		m.MinimockSendMsgDone() &&
		m.MinimockSetHeaderDone() &&
		m.MinimockSetTrailerDone()
}
